(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["xutils"] = factory();
	else
		root["xutils"] = factory();
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./lib/index.ts":
/*!**********************!*\
  !*** ./lib/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./utils */ "./lib/utils/index.ts"), exports);


/***/ }),

/***/ "./lib/utils/_ElapsedTime.ts":
/*!***********************************!*\
  !*** ./lib/utils/_ElapsedTime.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ElapsedTime = void 0;
const _datetime_1 = __webpack_require__(/*! ./_datetime */ "./lib/utils/_datetime.ts");
const _number_1 = __webpack_require__(/*! ./_number */ "./lib/utils/_number.ts");
class ElapsedTime {
    /**
     * New instance
     */
    constructor() {
        this.start_time = new Date();
        this.stop_time = undefined;
        this._ms = undefined;
    }
    /**
     * Start time tracking (sets start_time to now and resets other properties)
     */
    start() {
        const _now = new Date();
        this.start_time = (0, _datetime_1._isDate)(this.start_time) ? this.start_time : _now;
        this.stop_time = undefined;
        this._ms = undefined;
        return this;
    }
    /**
     * Track current time (sets this._ms to time difference between last start and now)
     *
     * @param updateStart  Set start to now
     */
    now(updateStart = false) {
        const _now = new Date();
        const _start = (0, _datetime_1._isDate)(this.start_time) ? this.start_time : this.start_time = _now;
        this._ms = _now.getTime() - _start.getTime();
        if (updateStart)
            this.start_time = _now;
        return this;
    }
    /**
     * Stop time tracking (sets this._ms to time difference between last start and last stop)
     * If last stop is less than start time, stop time is updated to now.
     */
    stop() {
        const _now = new Date();
        const _start = (0, _datetime_1._isDate)(this.start_time) ? this.start_time : _now, t = _start.getTime();
        const _stop_time = this.stop_time;
        const _stop = (0, _datetime_1._isDate)(_stop_time) && _stop_time.getTime() >= t ? _stop_time : this.stop_time = _now;
        this._ms = _stop.getTime() - t;
        return this;
    }
    /**
     * Whether time tracking was started
     */
    started() {
        return (0, _datetime_1._isDate)(this.start_time);
    }
    /**
     * Whether time tracking was stopped
     */
    stopped() {
        return (0, _datetime_1._isDate)(this.stop_time);
    }
    /**
     * Get tracked elapsed time in milliseconds
     *
     * @returns milliseconds
     */
    ms() {
        return parseInt(this._ms);
    }
    /**
     * Get tracked elapsed time in seconds
     *
     * @param decimalPlaces
     * @returns seconds
     */
    sec(decimalPlaces = 3) {
        return (0, _number_1._round)(this.ms() / 1000, decimalPlaces);
    }
    /**
     * Get tracked elapsed time in minutes
     *
     * @param decimalPlaces
     * @returns minutes
     */
    min(decimalPlaces = 3) {
        return (0, _number_1._round)(this.ms() / 60000, decimalPlaces);
    }
    /**
     * Get tracking data (this will stop tracking)
     */
    data() {
        this.stop();
        const start_time = (0, _datetime_1._isDate)(this.start_time) ? this.start_time : undefined;
        const stop_time = (0, _datetime_1._isDate)(this.stop_time) ? this.stop_time : undefined;
        const elapsed_ms = this.ms();
        return { start_time, stop_time, elapsed_ms };
    }
}
exports.ElapsedTime = ElapsedTime;


/***/ }),

/***/ "./lib/utils/_batch.ts":
/*!*****************************!*\
  !*** ./lib/utils/_batch.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._batchValues = void 0;
/**
 * Split `array` into batches `T[][]` of specified size.
 * - i.e. `_batchValues<number>([1,2,3,4,5,6,7,8], 3)` => `[[1,2,3],[4,5,6],[7,8]]`
 *
 * @param array  Batch values
 * @param batchSize  Batch size `x > 0`.
 * @returns  `T[][]`
 */
const _batchValues = (array, batchSize) => {
    if (!(Number.isInteger(batchSize) && batchSize > 0))
        throw new Error('Invalid batch size.');
    const _array = array.slice(0), _buffer = [];
    while (_array.length)
        _buffer.push(_array.splice(0, batchSize));
    return _buffer;
};
exports._batchValues = _batchValues;


/***/ }),

/***/ "./lib/utils/_datetime.ts":
/*!********************************!*\
  !*** ./lib/utils/_datetime.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._timestamp = exports._datetime = exports._getDate = exports._isDate = void 0;
/**
 * Validate `Date` instance
 *
 * @param value
 */
const _isDate = (value) => value instanceof Date && !isNaN(value.getTime());
exports._isDate = _isDate;
/**
 * Get/create `Date` instance
 *
 * @param value  Parse value ~ `value instanceOf Date ? value : new Date(value)`
 * @param _default  Parse default on failure [default: `undefined` => `new Date()`]
 */
const _getDate = (value, _default) => {
    if (!(0, exports._isDate)(value) && !(0, exports._isDate)(value = new Date(value))) {
        if (_default instanceof Date)
            value = _default;
        else if (_default === undefined)
            value = new Date();
        else
            value = new Date(_default);
    }
    return value;
};
exports._getDate = _getDate;
/**
 * Convert `Date` value to datetime format (i.e. `2023-05-27 22:11:57` ~ `YYYY-MM-DD HH:mm:ss`)
 *
 * @param value  Parse value ~ `value instanceOf Date ? value : new Date(value)`
 * @param _default  Parse default on failure [default: `undefined` => `new Date()`]
 */
const _datetime = (value, _default) => {
    const date = (0, exports._getDate)(value, _default), _pad = (v) => `${v}`.padStart(2, '0');
    return !(0, exports._isDate)(date) ? `${date}` : `${date.getFullYear()}-${_pad(date.getMonth() + 1)}-${_pad(date.getDate())} ${_pad(date.getHours())}:${_pad(date.getMinutes())}:${_pad(date.getSeconds())}`;
};
exports._datetime = _datetime;
/**
 * Convert `Date` value to ISO format (i.e. `new Date().toISOString()` ~ `2023-05-27T19:30:44.575Z`)
 *
 * @param value  Parse value ~ `value instanceOf Date ? value : new Date(value)`
 * @param _default  Parse default on failure [default: `undefined` => `new Date()`]
 */
const _timestamp = (value, _default) => {
    const date = (0, exports._getDate)(value, _default);
    return !(0, exports._isDate)(date) ? `${date}` : date.toISOString();
};
exports._timestamp = _timestamp;
//..
/*
//TESTS:
console.log(`_getDate() => new Date() =>`, _getDate());
console.log(`_getDate('2023-05-27T19:30:44.575Z') =>`, _getDate('2023-05-27T19:30:44.575Z'));
console.log(`_getDate(1685215844575) =>`, _getDate(1685215844575));
console.log(`_getDate(NaN) => new Date() =>`, _getDate(NaN));
console.log(`_getDate(NaN, null) => `, _getDate(NaN, null));
console.log(`_getDate(NaN, new Date()) => `, _getDate(NaN, new Date()));
console.log(`_getDate(NaN, NaN) => `, _getDate(NaN, NaN));
console.log(`_getDate(NaN, 1685215844575) => `, _getDate(NaN, 1685215844575));
console.log(`_getDate(NaN, '2023-05-27T19:30:44.575Z') => `, _getDate(NaN, '2023-05-27T19:30:44.575Z'));
console.log(`_getDate(NaN, 'midnight') => `, _getDate(NaN, 'midnight'));

//RESULTS:
// _getDate() => new Date() => 2023-05-27T20:39:19.821Z
// _getDate('2023-05-27T19:30:44.575Z') => 2023-05-27T19:30:44.575Z
// _getDate(1685215844575) => 2023-05-27T19:30:44.575Z
// _getDate(NaN) => new Date() => 2023-05-27T20:39:19.823Z
// _getDate(NaN, null) =>  1970-01-01T00:00:00.000Z
// _getDate(NaN, new Date()) =>  2023-05-27T20:39:19.824Z
// _getDate(NaN, NaN) =>  Invalid Date
// _getDate(NaN, 1685215844575) =>  2023-05-27T19:30:44.575Z
// _getDate(NaN, '2023-05-27T19:30:44.575Z') =>  2023-05-27T19:30:44.575Z
// _getDate(NaN, 'midnight') =>  Invalid Date
*/ 


/***/ }),

/***/ "./lib/utils/_debouced.ts":
/*!********************************!*\
  !*** ./lib/utils/_debouced.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._debouced = void 0;
/**
 * Create debounced callback function
 *
 * @param handler  Throttled callback handler
 * @param delay  Callback delay milliseconds
 * @param maxWait  Maximum callback delay milliseconds
 * @param immediate  Execute callback before delay
 * @returns Throttled callback function
 */
const _debouced = (handler, delay = 200, maxWait = 0, immediate = false) => {
    delay = !isNaN(delay = parseFloat(delay)) && delay >= 0 ? delay : 200;
    maxWait = !isNaN(maxWait = parseFloat(maxWait)) && maxWait >= 0 && maxWait > delay ? maxWait : 0;
    immediate = !!immediate;
    let immediateTimer, callTimer, waitTimer, nextCall;
    const execute = (is_immediate) => {
        let next = nextCall;
        nextCall = undefined;
        if (waitTimer) {
            clearTimeout(waitTimer);
            waitTimer = undefined;
        }
        if (callTimer && !is_immediate) {
            clearTimeout(callTimer);
            callTimer = undefined;
        }
        if ((next === null || next === void 0 ? void 0 : next.length) && 'function' === typeof handler)
            handler.apply(...next);
        if (delay && immediate && !is_immediate) {
            immediateTimer = setTimeout(() => {
                clearTimeout(immediateTimer);
                immediateTimer = undefined;
            }, delay);
        }
    };
    const wrapper = function (...args) {
        nextCall = [this, args];
        if (!delay)
            return execute();
        const _next = (no_wait = 0) => {
            clearTimeout(callTimer);
            callTimer = setTimeout(() => execute(), delay);
            if (!no_wait && maxWait && !waitTimer)
                waitTimer = setTimeout(() => execute(), maxWait);
        };
        if (!(immediate && !immediateTimer && !callTimer))
            return _next();
        _next(1);
        execute(1);
    };
    Object.defineProperties(wrapper, {
        length: { value: handler.length },
        name: { value: `${handler.name || 'anonymous'}__debounced__${delay}` },
    });
    return wrapper;
};
exports._debouced = _debouced;


/***/ }),

/***/ "./lib/utils/_hello.ts":
/*!*****************************!*\
  !*** ./lib/utils/_hello.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._sayHello = void 0;
/**
 * Say Hello!
 *
 * @param name
 */
const _sayHello = (name) => {
    name = (name === null || name === void 0 ? void 0 : name.length) ? name : 'Thuku';
    const hello = `[x] - Hello ${name}!`;
    console.log(hello);
    return hello;
};
exports._sayHello = _sayHello;


/***/ }),

/***/ "./lib/utils/_json.ts":
/*!****************************!*\
  !*** ./lib/utils/_json.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._jsonClone = exports._jsonParse = exports._jsonStringify = void 0;
/**
 * Custom `JSON.stringify` with extended custom replacer
 * - Default value for `undefined` value argument
 * - Fix `Error`, `Set`, `Map` stringify
 * - Circular reference fixes
 *
 * @param value  Parse value (`undefined` value is replaced with `_undefined` argument substitute value)
 * @param space  Indentation space
 * @param _undefined  Default `undefined` argument `value` substitute (default `null`)
 * @returns
 */
const _jsonStringify = (value, space, _undefined = null) => {
    const _space = space === null ? undefined : space;
    const parents = [];
    const path = ['this'];
    const refs = new Map();
    const _clear = () => {
        refs.clear();
        parents.length = 0;
        path.length = 1;
    };
    const _parents = (key, value) => {
        let i = parents.length - 1, prev = parents[i];
        if (prev[key] === value || i === 0) {
            path.push(key);
            parents.push(value);
            return;
        }
        while (i-- >= 0) {
            prev = parents[i];
            if ((prev === null || prev === void 0 ? void 0 : prev[key]) === value) {
                i += 2;
                parents.length = i;
                path.length = i;
                --i;
                parents[i] = value;
                path[i] = key;
                break;
            }
        }
    };
    const _replacer = function (key, value) {
        if (value === null)
            return value;
        if (value instanceof Error)
            value = { [`[Error]`]: String(value) };
        if (value instanceof Set)
            value = { '[Set]': [...value] };
        if (value instanceof Map)
            value = { '[Map]': [...value] };
        if ('object' === typeof value) {
            if (key)
                _parents(key, value);
            const other = refs.get(value);
            if (other)
                return '[Circular]' + other;
            else
                refs.set(value, path.join('.'));
        }
        return value;
    };
    try {
        if (value === undefined)
            value = _undefined !== undefined ? _undefined : _undefined = null;
        parents.push(value);
        return JSON.stringify(value, _replacer, _space);
    }
    finally {
        _clear();
    }
};
exports._jsonStringify = _jsonStringify;
/**
 * Custom `JSON.parse` with error catch and default result on parse failure
 *
 * @param value
 * @param _default
 * @returns
 */
const _jsonParse = (value, _default) => {
    try {
        return JSON.parse(value);
    }
    catch (e) {
        return _default;
    }
};
exports._jsonParse = _jsonParse;
/**
 * Clone value via json stringify and parse
 *
 * @param value  Parse value
 * @param space  Indentation space
 * @param _undefined  Default `undefined` argument `value` substitute (default `null`)
 */
const _jsonClone = (value, space, _undefined = null) => {
    let val = (0, exports._jsonStringify)(value, space, _undefined);
    if (val !== undefined)
        val = (0, exports._jsonParse)(val);
    return val;
};
exports._jsonClone = _jsonClone;


/***/ }),

/***/ "./lib/utils/_number.ts":
/*!******************************!*\
  !*** ./lib/utils/_number.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._rand = exports._commas = exports._round = exports._int = exports._num = exports._toNum = exports._isNumeric = void 0;
/**
 * Check if value is numeric
 *
 * @param value  Parse value
 * @param booleans  Pass `boolean` values as numeric
 * @param blanks  Pass empty `string` values (because `!isNaN('') === true`)
 * @returns `boolean` is numeric
 */
const _isNumeric = (value, booleans = false, blanks = false) => {
    if ('number' === typeof value)
        return !isNaN(value);
    if ('boolean' === typeof value)
        return !!booleans;
    const v = String(value).trim();
    if (v === '')
        return !!blanks;
    return /(^[+-]?[0-9]+([.][0-9]+)?([eE][+-]?[0-9]+)?$)|(^[+-]?\.[0-9]+$)|(^[+-]?[0-9]+\.$)/.test(v);
};
exports._isNumeric = _isNumeric;
/**
 * Convert value to normalized number
 *
 * - Blank trimmed `string` value is considered `NaN` (i.e. "")
 *
 * @param value  Parse value
 * @param _default  [default: `NaN`] Default result when parse result is `NaN`
 * @param fixFloat  [default: `true`] Whether to fix float zeros (i.e. `1.1/100` = `0.011000000000000001` => `0.011`)
 * @returns `number` parsed
 */
const _toNum = (value, _default = NaN, fixFloat = true) => {
    let num = value;
    if ('number' !== typeof value) {
        if ('string' === typeof value) {
            let p = /^\s*([\+-])\s*/, matches = value.match(p); //match prefix +/-
            if (matches)
                value = value.replace(p, ''); //remove prefix +/-
            value = value.replace(/^\s*[\+-]/, '').trim(); //remove prefix +/-
            if (value.match(/^\d{1,3}(,\d{3})*(\.|(\.\d+))?$/))
                value = value.replace(/,/g, '').trim(); //match and remove "," thousand separator
            if (!value.match(/^\d*(\.|(\.\d+))?$/))
                value = 'x'; //invalidate invalid leading decimal (i.e. '.10')
            else if (matches)
                value = matches[1] + value; //restore prefix +/-
        }
        num = !isNaN(num = Number(value)) ? num : parseFloat(num); //parse number
    }
    if (!(num !== '' && num !== null && !isNaN(num = Number(num))))
        return _default; //return default when value is not not numeric
    let val, matches, places = 5; //fix float - max 5 decimal places
    if (fixFloat && new RegExp(`\\.\\d*(0{${3}}\\d*)`).test(val = String(num)) && (matches = val.match(/\.(\d+)/))) {
        let floats = matches[1], len = floats.length, n = -1, x = -1;
        for (let i = len - 1; i >= 0; i--) {
            if (!Number(floats[i])) {
                if (x < 0)
                    x = i;
            }
            else if (x > -1) {
                n = i;
                if (x - n >= places)
                    break;
                else
                    x = n = -1;
            }
        }
        if (n > -1 && x > -1 && (x - n >= places))
            num = +val.substring(0, val.length - len + x + 1);
    }
    return num;
};
exports._toNum = _toNum;
/**
 * Parse value to number (shorthand)
 *
 * @param value  Parse value
 * @param _default  [default: `NaN`] Default result when parse result is `NaN`
 * @returns `number` parsed
 */
const _num = (value, _default = NaN) => (0, exports._toNum)(value, _default);
exports._num = _num;
/**
 * Parse value to integer
 *
 * @param value  Parse value
 * @param _default  [default: `NaN`] Default result when parse result is `NaN`
 * @returns `number` integer
 */
const _int = (value, _default = NaN) => parseInt(String((0, exports._toNum)(value, _default)));
exports._int = _int;
/**
 * Round number to decimal places
 *
 * @param value  Parse value
 * @param places  [default: `2`] Decimal places
 * @returns `number` rounded
 */
const _round = (value, places = 2) => {
    if (isNaN(value))
        return NaN;
    let p = Math.pow(10, Math.abs((0, exports._int)(places, 2)));
    return Math.round((value + Number.EPSILON) * p) / p;
};
exports._round = _round;
/**
 * Convert numeric value to comma thousand delimited string (i.e. `1000.4567` => `'1,000.45'`)
 *
 * @param value  Parse value
 * @param places  [default: `2`] Round decimal places
 * @param zeros  Enable trailing `'0'` decimal places (i.e. `1000` => `'1,000.00'`)
 * @returns `string` Comma thousand delimited number (returns `""` if parsed `value` is `NaN`)
 */
const _commas = (value, places = 2, zeros = false) => {
    const num = (0, exports._round)((0, exports._num)(value), places = (0, exports._int)(places, 2));
    if (isNaN(num)) {
        console.warn('[WARNING: `_commas`] NaN value:', value);
        return '';
    }
    let val = String(num).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
    if (places && zeros) {
        if (val.indexOf('.') === -1)
            val += '.'.padEnd(places + 1, '0');
        else
            val = val.split('.').reduce((prev, v, i) => {
                prev.push(i === 1 && v.length < places ? v.padEnd(places, '0') : v);
                return prev;
            }, []).join('.');
    }
    return val;
};
exports._commas = _commas;
/**
 * Generate random `integer` number.
 *
 * @param min  Min `integer`
 * @param max  Max `integer`
 * @returns  `number` Random `integer`
 */
const _rand = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
exports._rand = _rand;


/***/ }),

/***/ "./lib/utils/_objects.ts":
/*!*******************************!*\
  !*** ./lib/utils/_objects.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._hasAnyProps = exports._hasProps = exports._hasProp = exports._flatten = void 0;
/**
 * Flatten array recursively
 *
 * @param values
 */
const _flatten = (values) => values.flat(Infinity);
exports._flatten = _flatten;
/**
 * Check if value has property
 *
 * @param value  Search `object` value
 * @param prop  Find property
 * @param own  [default: `false`] As own property
 *
 */
const _hasProp = (value, prop, own = false) => {
    if (!('object' === typeof value && value))
        return false;
    return Object.prototype.hasOwnProperty.call(value, prop) || (own ? false : prop in value);
};
exports._hasProp = _hasProp;
/**
 * Check if object has properties
 *
 * @param value  Search `object` value
 * @param props  Spread find properties
 *
 */
const _hasProps = (value, ...props) => !props.length ? false : !props.filter((k) => !(0, exports._hasProp)(value, k)).length;
exports._hasProps = _hasProps;
/**
 * Check if object has any of the properties
 *
 * @param value  Search `object` value
 * @param props  Spread find properties
 *
 */
const _hasAnyProps = (value, ...props) => !props.length ? false : !!props.filter((k) => (0, exports._hasProp)(value, k)).length;
exports._hasAnyProps = _hasAnyProps;


/***/ }),

/***/ "./lib/utils/_promise.ts":
/*!*******************************!*\
  !*** ./lib/utils/_promise.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._sleep = exports._asyncValues = exports._asyncAll = void 0;
/**
 * Parallel resolve `array` values callback promises
 * - i.e. await _asyncAll<number, number>([1, 2], async (num) => num * 2) --> [{status: 'resolved', index: 0, value: 2}, {status: 'resolved', index: 1, value: 4}]
 *
 * @param array  Entries
 * @param callback  Entry callback
 * @returns `Promise<IPromiseResult<TResult>[]>`
 */
const _asyncAll = (array, callback) => __awaiter(void 0, void 0, void 0, function* () {
    return new Promise((resolve) => {
        const _buffer = [], _len = array.length;
        const _resolve = () => resolve(_buffer);
        if (!_len)
            return _resolve();
        let count = 0;
        array.forEach((v, i, a) => {
            (() => __awaiter(void 0, void 0, void 0, function* () { return Promise.resolve(callback ? callback(v, i, a) : v); }))()
                .then(value => _buffer.push({ status: 'resolved', index: i, value }))
                .catch(reason => _buffer.push({ status: 'rejected', index: i, reason }))
                .finally(() => ++count === _len ? _resolve() : undefined);
        });
    });
});
exports._asyncAll = _asyncAll;
/**
 * Get async iterable values (i.e. `for await (const value of _asyncValues(array)){...}`)
 *
 * @param array  Values
 * @returns Async iterable object
 */
const _asyncValues = (array) => ({
    values: () => array,
    size: () => array.length,
    each(callback) {
        var _a, e_1, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            let self = this, cancel = false, index = -1, _break = () => {
                cancel = true;
            };
            try {
                for (var _d = true, self_1 = __asyncValues(self), self_1_1; self_1_1 = yield self_1.next(), _a = self_1_1.done, !_a; _d = true) {
                    _c = self_1_1.value;
                    _d = false;
                    const value = _c;
                    index++;
                    if (cancel)
                        break;
                    yield callback(value, index, self.size(), _break);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = self_1.return)) yield _b.call(self_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    },
    [Symbol.asyncIterator]() {
        let index = 0;
        const that = this;
        return {
            next() {
                return __awaiter(this, void 0, void 0, function* () {
                    let value = undefined, length = that.size();
                    if (index >= length)
                        return { done: true, value };
                    value = yield Promise.resolve(array[index]);
                    index++;
                    return { done: false, value };
                });
            },
        };
    },
});
exports._asyncValues = _asyncValues;
/**
 * Delay promise
 *
 * @param timeout  Delay milliseconds
 * @returns `Promise<number>` timeout
 */
const _sleep = (timeout) => __awaiter(void 0, void 0, void 0, function* () {
    timeout = !isNaN(timeout) && timeout >= 0 ? timeout : 0;
    return new Promise(resolve => setTimeout(() => resolve(timeout), timeout));
});
exports._sleep = _sleep;


/***/ }),

/***/ "./lib/utils/_queue.ts":
/*!*****************************!*\
  !*** ./lib/utils/_queue.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._queue = void 0;
/**
 * Create queue object
 *
 * @returns `IQueue`
 */
const _queue = () => {
    const items = {};
    let head = 0;
    let tail = 0;
    return {
        get count() {
            return tail;
        },
        get length() {
            return tail - head;
        },
        get isEmpty() {
            return this.length === 0;
        },
        enqueue(value) {
            items[tail] = value;
            tail++;
        },
        dequeue() {
            const item = items[head];
            delete items[head];
            head++;
            return item;
        },
        peek() {
            return items[head];
        },
        values() {
            return Object.values(items);
        },
    };
};
exports._queue = _queue;


/***/ }),

/***/ "./lib/utils/_sort.ts":
/*!****************************!*\
  !*** ./lib/utils/_sort.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._sortValues = void 0;
/**
 * Sort array values
 *
 * @param array
 * @param sort
 * @returns Sorted `array`
 */
const _sortValues = (array, sort) => {
    const _compare = (a, b) => {
        if ('string' === typeof a && 'string' === typeof b && 'function' === typeof (a === null || a === void 0 ? void 0 : a.localeCompare))
            return a.localeCompare(b);
        return a > b ? 1 : (a < b ? -1 : 0);
    };
    const _direction = (val) => {
        if ('number' === typeof val && [1, -1].includes(val))
            return val;
        if ('string' === typeof val) {
            if (val.startsWith('asc'))
                return 1;
            if (val.startsWith('desc'))
                return -1;
        }
        return 1;
    };
    const _method = () => {
        if (Object(sort) === sort) {
            const _entries = Object.entries(sort);
            if (_entries.length)
                return (a, b) => {
                    let i, result;
                    for (result = 0, i = 0; result === 0 || i < _entries.length; i++) {
                        const [key, val] = _entries[i];
                        result = _compare(a === null || a === void 0 ? void 0 : a[key], b === null || b === void 0 ? void 0 : b[key]) * _direction(val);
                    }
                    return result;
                };
        }
        return (a, b) => _compare(a, b) * _direction(sort);
    };
    return array.sort(_method());
};
exports._sortValues = _sortValues;


/***/ }),

/***/ "./lib/utils/_string.ts":
/*!******************************!*\
  !*** ./lib/utils/_string.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._camelCase = exports._studlyCase = exports._slugCase = exports._snakeCase = exports._sentenceCase = exports._titleCase = exports._rtrim = exports._ltrim = exports._trim = exports._strEscape = exports._regEscape = exports._strNorm = exports._str = exports._stringable = exports._string = exports._uuid = void 0;
const _json_1 = __webpack_require__(/*! ./_json */ "./lib/utils/_json.ts");
/**
 * Get unique string of random characters (in lowercase)
 *
 * @param length  (max 64)
 */
function _uuid(length) {
    const _uid = () => Math.random().toString(36).substring(2) + (new Date()).getTime().toString(36);
    if (!(length !== undefined && Number.isInteger(length) && length > 0 && length <= 64))
        return _uid();
    let buffer = '';
    while (buffer.length < length)
        buffer += _uid();
    return buffer.substring(0, length);
}
exports._uuid = _uuid;
/**
 * Safely `string` cast value
 * - Returns ISO format timestamp for valid Date value
 *
 * @param value  Cast value
 * @param _default  [default: `''`] Default result on failure
 */
const _string = (value, _default = '') => {
    let val = '';
    try {
        if (value instanceof Date && !isNaN(value.getTime()))
            val = value.toISOString();
        else
            val = String(value);
    }
    catch (e) {
        val = _default;
    }
    return val;
};
exports._string = _string;
/**
 * Safely `string` cast value if possible.
 *
 * @param value
 * @returns `false|string` Cast result or `false` on failure
 */
const _stringable = (value) => {
    const failed = `!${Date.now()}!`, val = (0, exports._string)(value, failed), pattern = /\[object \w+\]/;
    return !(val === failed || pattern.test(val)) ? val : false;
};
exports._stringable = _stringable;
/**
 * Convert value to `string` equivalent
 *
 * - Returns '' for `null` and `undefined` value
 * - When `stringify` is `false`, returns '' for `array` or `object` value that does not implement `toString()` method
 *
 * @param value
 * @param trim  Trim result
 * @param stringify  Stringify `array` or `object` value that does not implement `toString()` method
 */
const _str = (value, trim = false, stringify = false) => {
    if ('string' !== typeof value) {
        if (value === null || value === undefined)
            return '';
        else if ('object' === typeof value) {
            if (Array.isArray(value))
                return stringify ? (0, _json_1._jsonStringify)(value) : '';
            const tmp = (0, exports._stringable)(value);
            if (tmp === false)
                return stringify ? (0, _json_1._jsonStringify)(value) : '';
            else
                value = tmp;
        }
        else
            value = (0, exports._string)(value);
    }
    return trim ? value.trim() : value;
};
exports._str = _str;
/**
 * Normalize string by removing accents (i.e. "Amélie" => "Amelie")
 *
 * @param value
 */
const _strNorm = (value) => (0, exports._str)(value).normalize('NFD').replace(/[\u0300-\u036f]/g, '');
exports._strNorm = _strNorm;
/**
 * Escape regex operators from string
 * - i.e. `'\\s\n\r\t\v\x00~_!@#$%^&*()[]\\/,.?"\':;{}|<>=+-'` => `'\\s\n\r\t\v\x00\s~_!@#\\$%\\^&\\*\\(\\)\\[\\]\\\\/,\\.\\?"\':;\\{\\}\\|<>=\\+-'`
 *
 * @param value
 */
const _regEscape = (value) => (0, exports._str)(value).replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
exports._regEscape = _regEscape;
/**
 * Escape string special characters
 * - i.e. `'\r\n\t\f\v\x00-\u00f3-\u1234-\xb4-\u000b-/\\'` => `'\\r\\n\\t\\f\\v\\x00-ó-ሴ-´-\\v-/\\\\'`
 *
 * @param value
 */
const _strEscape = (value) => JSON.stringify((0, exports._str)(value))
    .replace(/\\u([\d\w]{4})/g, (m, s) => {
    const h = parseInt(s, 16);
    return h > 255 ? m : '\\' + encodeURIComponent(String.fromCharCode(h)).replace('%', 'x').replace('x0B', 'v');
})
    .replace(/^"|"$/g, '')
    .replace(/\\"/g, '"');
exports._strEscape = _strEscape;
/**
 * Regex string trim characters
 *
 * @param value  Trim value
 * @param chars  Strip characters [default: `' \n\r\t\f\v\x00'`] - use `'{default}'` to include defaults (i.e `'-{defaults}'` == `'- \n\r\t\f\v\x00'`)
 * @param rl  Trim mode (`''` => (default) trim right & left, `'r'|'right'` => trim right, `'l'|'left'` => trim left)
 */
const _trim = (value, chars = ' \r\n\t\f\v\x00', rl = '') => {
    value = (0, exports._str)(value);
    if (!chars.length)
        return value;
    chars = chars.replace(/\{default\}/, ' \r\n\t\f\v\x00');
    let d1 = 0, d2 = 0;
    let _chars = [...new Set([...chars])].filter(v => {
        if (v === '-') {
            d1 = 1;
            return false;
        }
        if (v === '_') {
            d2 = 1;
            return false;
        }
        return true;
    });
    if (d2)
        _chars.unshift('_');
    if (d1)
        _chars.unshift('-');
    let p = `[${(0, exports._regEscape)(_chars.join(''))}]*`, pattern = `^${p}|${p}$`;
    if (['l', 'left'].includes(rl))
        pattern = `^${p}`;
    else if (['r', 'right'].includes(rl))
        pattern = `${p}$`;
    return value.replace(new RegExp(pattern, 'gs'), '');
};
exports._trim = _trim;
/**
 * Regex string trim leading characters (left)
 *
 * @param value Trim value
 * @param chars Strip characters [default: `' \n\r\t\f\v\x00'`] - use `'{default}'` to include defaults (i.e `'-{defaults}'` == `'- \n\r\t\f\v\x00'`)
 */
const _ltrim = (value, chars = ' \r\n\t\f\v\x00') => (0, exports._trim)(value, chars, 'left');
exports._ltrim = _ltrim;
/**
 * Regex string trim trailing characters (right)
 *
 * @param value Trim value
 * @param chars Strip characters [default: `' \n\r\t\f\v\x00'`] - use `'{default}'` to include defaults (i.e `'-{defaults}'` == `'- \n\r\t\f\v\x00'`)
 */
const _rtrim = (value, chars = ' \r\n\t\f\v\x00') => (0, exports._trim)(value, chars, 'right');
exports._rtrim = _rtrim;
/**
 * Convert string to title case (i.e. "heLLo woRld" => "Hello World")
 *
 * @param value  Parse string
 * @param keepCase  Disable lowercasing uncapitalized characters
 */
const _titleCase = (value, keepCase = false) => (0, exports._str)(value)
    .replace(/\w\S*/g, match => match[0].toUpperCase()
    + (keepCase ? match.substring(1) : match.substring(1).toLowerCase()));
exports._titleCase = _titleCase;
/**
 * Convert string to sentence case
 *
 * @param value  Parse string
 * @param keepCase  Disable lowercasing uncapitalized characters
 */
const _sentenceCase = (value, keepCase = false) => (0, exports._str)(value)
    .split(/((?<=\.|\?|!)\s*)/)
    .map(val => {
    if (val.length) {
        const first = val.charAt(0).toUpperCase();
        const rest = val.length > 1 ? val.slice(1) : '';
        val = first + (keepCase ? rest : rest.toLowerCase());
    }
    return val;
})
    .join('');
exports._sentenceCase = _sentenceCase;
/**
 * Convert value to snake case (i.e. 'HelloWorld' => 'hello_world')
 * - accents are normalized (i.e. "Test Amélie" => "test_amelie")
 *
 * @param value  Parse string
 * @param trimTrailing  Trim trailing "_" (`false` = (default) disabled, `true` => trim right & left, `'r'|'right'` => trim right, `'l'|'left'` => trim left)
 */
const _snakeCase = (value, trimTrailing = false) => {
    let res = (0, exports._strNorm)((0, exports._trim)(value))
        .replace(/[A-Z]+/g, m => m[0].toUpperCase() + m.substring(1).toLowerCase())
        .replace(/\W+/g, ' ')
        .split(/ |(?=[A-Z])/).join('_').replace(/_+/g, '_').toLowerCase();
    if (res === '_')
        return '';
    if (/^_|_$/.test(res) && trimTrailing)
        res = (0, exports._trim)(res, '_', (['l', 'left', 'r', 'right'].includes(trimTrailing) ? trimTrailing : ''));
    return res;
};
exports._snakeCase = _snakeCase;
/**
 * Convert value to slug case (i.e. 'HelloWorld' => 'hello-world')
 *
 * @param value  Parse string
 */
const _slugCase = (value, trimTrailing = false) => (0, exports._snakeCase)(value, trimTrailing).replace(/_/g, '-');
exports._slugCase = _slugCase;
/**
 * Convert value to studly case (i.e. 'hello-world' => 'HelloWorld')
 *
 * @param value  Parse string
 */
const _studlyCase = (value) => (0, exports._snakeCase)(value)
    .split('_')
    .filter(v => v.length)
    .map(word => word[0].toUpperCase() + word.substring(1).toLowerCase())
    .join('');
exports._studlyCase = _studlyCase;
/**
 * Convert value to camel case (i.e. 'hello-world' => 'helloWorld')
 *
 * @param value  Parse string
 */
const _camelCase = (value) => {
    let res = (0, exports._studlyCase)(value);
    if (res.length)
        res = res[0].toLowerCase() + res.substring(1);
    return res;
};
exports._camelCase = _camelCase;


/***/ }),

/***/ "./lib/utils/_term.ts":
/*!****************************!*\
  !*** ./lib/utils/_term.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Term = void 0;
const _string_1 = __webpack_require__(/*! ./_string */ "./lib/utils/_string.ts");
const _json_1 = __webpack_require__(/*! ./_json */ "./lib/utils/_json.ts");
/**
 * Term `console.*` logger
 */
class Term {
    /**
     * Get standardized text formats
     *
     * @param formats Text format(s)
     * @returns `string[]`
     */
    static getFormats(formats) {
        const FM = this.FORMATS;
        const PF = this.PREDEFINED_FORMATS;
        const _formats = Array.isArray(formats) ? formats : 'string' === typeof formats ? [formats] : [];
        return _formats.reduce((prev, val) => {
            if ((val = val.trim().toLowerCase()) && val !== 'reset') {
                let tmp = val = val.replace(/[^a-z0-9]/ig, '_').replace('grey', 'gray');
                const _addPF = (k) => {
                    const v = PF[k];
                    if (Array.isArray(v))
                        prev.push(...v);
                    else if ('string' === typeof v)
                        prev.push(v);
                };
                if (FM.hasOwnProperty(val))
                    prev.push(val);
                else if (FM.hasOwnProperty(tmp = `fg_${val}`))
                    prev.push(tmp);
                else if (PF.hasOwnProperty(val))
                    _addPF(val);
                else if (PF.hasOwnProperty(tmp = `bg_${val}`))
                    _addPF(tmp);
            }
            return prev;
        }, []);
    }
    /**
     * Text format log arguments
     *
     * @param formats  Text format(s)
     * @param args  Format values
     * @returns `ITermFormat`
     */
    static format(formats, ...args) {
        let tmp;
        const _formats = this.getFormats(formats);
        const _format = (val) => {
            if (this.DISABLED || !formats.length)
                return val;
            if ('object' === typeof val && val) {
                if (Array.isArray(val))
                    return val;
                if (new RegExp('\\[object \\w+\\\]').test(tmp = (0, _string_1._string)(val)))
                    return val;
                else
                    val = tmp;
            }
            if (!('string' === typeof val && val.length))
                return val;
            return _formats.reduce((v, f) => this.FORMATS[f] + v + this.FORMATS.reset, val);
        };
        const that = this, _args = args;
        return {
            /**
             * Add formatted values
             *
             * @param formats
             * @param args
             */
            format(formats, ...args) {
                _args.push(that.format(formats, ...args).values());
                return this;
            },
            /**
             * Get formatted values
             *
             * @param args
             */
            values(...args) {
                return _args.concat(args).map(val => _format(val));
            },
            /**
             * Get values without formatting
             *
             * @param args
             */
            clear(...args) {
                return that.clear(...this.values(...args));
            },
            /**
             * `console.log` formatted values
             *
             * @param args
             */
            log(...args) {
                console.log(...this.values(...args));
            },
            /**
             * `console.debug` formatted values
             *
             * @param args
             */
            debug(...args) {
                console.debug(...this.values(...args));
            },
            /**
             * `console.warn` formatted values
             *
             * @param args
             */
            warn(...args) {
                console.warn(...this.values(...args));
            },
            /**
             * `console.error` formatted values
             *
             * @param args
             */
            error(...args) {
                console.error(...this.values(...args));
            },
            /**
             * `console.info` formatted values
             *
             * @param args
             */
            info(...args) {
                console.info(...this.values(...args));
            },
        };
    }
    /**
     * Clear text value formatting
     *
     * @param args  Formatted values
     * @returns `any[]` Clear values
     */
    static clear(...args) {
        const _clear = (val) => Object.values(this.FORMATS).reduce((p, v) => p.replace(new RegExp(String(v).replace(/\x1B/, '\\x1B').replace(/\[/, '\\['), 'g'), ''), val);
        return args.map((val) => 'string' === typeof val && val.trim().length ? _clear(val) : val);
    }
    /**
     * Get formatted text
     *
     * @param value  Text value
     * @param formats  Text format(s)
     * @returns `string` Formatted
     */
    static text(value, formats) {
        const _val = (0, _string_1._string)(value), _formats = (Array.isArray(formats) ? formats : 'string' === typeof formats ? [formats] : []).filter(v => 'string' === typeof v && !!v.trim());
        if (!(_formats.length && _val.trim().length))
            return _val;
        return this.format(_formats, _val).values()[0];
    }
    /**
     * Log `console.log` format
     *
     * @param args
     */
    static log(...args) {
        this.format('log', ...args).log();
    }
    /**
     * Debug `console.debug` format
     *
     * @param args
     */
    static debug(...args) {
        this.format('debug', ...args).debug();
    }
    /**
     * Error `console.error` format
     *
     * @param args
     */
    static error(...args) {
        this.format('error', ...args).error();
    }
    /**
     * Warn `console.warn` format
     *
     * @param args
     */
    static warn(...args) {
        this.format('warn', ...args).warn();
    }
    /**
     * Info `console.info` format
     *
     * @param args
     */
    static info(...args) {
        this.format('info', ...args).info();
    }
    /**
     * Success `console.log` format
     *
     * @param args
     */
    static success(...args) {
        this.format('success', ...args).log();
    }
    /**
     * Get value list
     *
     * @param value
     * @param _entries
     */
    static list(value, _entries = false) {
        var _a;
        let items = [value], type = 'values';
        if ('object' === typeof value && value) {
            if (!(type = (_a = value[Symbol.iterator]) === null || _a === void 0 ? void 0 : _a.name)) {
                type = 'values';
                items = [value];
                if (_entries && (0, _string_1._stringable)(value) === false) {
                    let tmp = (0, _json_1._jsonClone)(value), tmp_entries = [];
                    if (!('object' === typeof tmp && tmp && (tmp_entries = Object.entries(tmp)).length))
                        tmp_entries = Object.entries(value);
                    if (tmp_entries.length) {
                        type = 'entries';
                        items = tmp_entries;
                    }
                }
            }
            else if (type === 'entries')
                items = _entries ? [...value] : [value];
            else
                items = [...value];
        }
        return [items, type];
    }
    /**
     * Custom `console.table` logger
     *
     * @param data
     * @param cellMaxLength
     */
    static table(data, cellMaxLength = 248, divider = false) {
        //vars
        const that = this;
        const [data_items, data_type] = that.list(data, 'object' === typeof data && data && !(0, _string_1._stringable)(data));
        //fn => str value
        const strVal = (val) => {
            let color, tmp;
            if (!Array.isArray(val) && (tmp = (0, _string_1._stringable)(val)) !== false) {
                color = 'green';
                if ('number' === typeof val)
                    color = 'yellow';
                else if (val === undefined || val === null)
                    color = 'gray';
                else if (val === true)
                    color = 'cyan';
                else if (val === false)
                    color = 'red';
                else if (/^\d{4}-(?:0[1-9]|1[0-2])-(?:[0-2][1-9]|[1-3]0|3[01])T(?:[0-1][0-9]|2[0-3])(?::[0-6]\d)(?::[0-6]\d)?(?:\.\d{3})?(?:[+-][0-2]\d:[0-5]\d|Z)?$/.test(tmp))
                    color = 'magenta'; //match ISO timestamp (i.e. 2023-06-09T18:18:57.070Z)
                val = tmp;
            }
            else {
                if ('object' === typeof val && val) {
                    const _type = val[Symbol.iterator];
                    if (!!_type) {
                        val = [...val];
                        if (_type === 'entries')
                            val = Object.fromEntries(val);
                    }
                    else
                        val = (0, _json_1._jsonClone)(val);
                }
                val = (0, _json_1._jsonStringify)(val);
                color = 'magenta';
            }
            return [val, color];
        };
        //value log - cannot be tabled
        if (data_type === 'values' && data_items.length < 2) {
            const [_value, _format] = strVal(data);
            console.log(that.text(_value, _format));
            return;
        }
        //table items
        let mode;
        const table_items = [];
        if (data_type === 'entries') {
            table_items.push(['(index)', 'Values']);
            table_items.push(...data_items);
        }
        else {
            let map_keys = [], map_items = [];
            data_items.forEach((data_item, r) => {
                let [list_items, list_type] = that.list(data_item, !r || mode === 'entries');
                if (!r)
                    mode = list_type;
                const map_item = {};
                list_items.forEach((item, i) => {
                    let k, v;
                    if (list_type === 'entries') {
                        k = (0, _string_1._str)(item[0], true, true);
                        v = item[1];
                    }
                    else {
                        k = `${i}`;
                        v = item;
                    }
                    if (!map_keys.includes(k))
                        map_keys.push(k);
                    map_item[k] = v;
                });
                map_items.push(map_item);
            });
            table_items.push(['(index)', ...map_keys]);
            map_items.forEach((map_item, r) => {
                const table_item = [];
                for (const key of map_keys)
                    table_item.push(map_item[key]);
                table_items.push([r, ...table_item]);
            });
        }
        //width
        const width_map = {};
        const str_items = [];
        table_items.forEach(table_item => {
            const str_item = [];
            table_item.forEach((val, i) => {
                const [_value, _format] = strVal(val);
                if (!width_map.hasOwnProperty(i))
                    width_map[i] = 0;
                let len = _value.length;
                if (len > cellMaxLength)
                    len = cellMaxLength; //cellMaxLength limit
                if (len > width_map[i])
                    width_map[i] = len;
                str_item.push([_value, _format]);
            });
            str_items.push(str_item);
        });
        //rows
        const rows_len = str_items.length;
        str_items.forEach((str_item, r) => {
            let max_lines = 0, str_item_lines = [];
            str_item.forEach((val, i) => {
                let [_value, _format] = val;
                if (!i || !r)
                    _format = (!i && r && mode === 'values') ? 'gray' : 'white';
                const width = width_map[i];
                const lines = [];
                if (_value.length > width) {
                    while (_value.length > width) {
                        const line = _value.substring(0, width).padEnd(width);
                        _value = _value.slice(width);
                        lines.push(that.text(line, _format)); //format
                    }
                    if (_value.length)
                        lines.push(that.text(_value.padEnd(width), _format)); //format
                }
                else
                    lines.push(that.text(_value.padEnd(width), _format)); //format
                str_item_lines.push(lines);
                if (max_lines < lines.length)
                    max_lines = lines.length;
            });
            str_item_lines = str_item_lines.map((lines, c) => {
                const width = width_map[c];
                return [...Array(max_lines)].map((_, i) => {
                    const line = i < lines.length ? lines[i] : ''.padEnd(width);
                    return line;
                });
            });
            const line_rows = [...Array(max_lines)].map(() => []);
            str_item_lines.forEach((lines, c) => {
                lines.forEach((line, i) => line_rows[i][c] = line);
            });
            const rows = [];
            const len = line_rows.length;
            line_rows.forEach((line_row, n) => {
                if (!n && !r)
                    rows.push('┌─' + line_row.map((_, i) => ''.padEnd(width_map[i], '─')).join('─┬─') + '─┐'); //border top
                rows.push('│ ' + line_row.join(' │ ') + ' │');
                if ((!r || divider) && n + 1 === len && r + 1 < rows_len)
                    rows.push('├─' + line_row.map((_, i) => ''.padEnd(width_map[i], '─')).join('─┼─') + '─┤'); //border mid
                if (n + 1 === len && r + 1 === rows_len)
                    rows.push('└─' + line_row.map((_, i) => ''.padEnd(width_map[i], '─')).join('─┴─') + '─┘'); //border bottom
            });
            rows.forEach(row => console.log(row));
        });
    }
}
exports.Term = Term;
/**
 * Disable formats
 */
Term.DISABLED = false;
/**
 * Text formats
 */
Term.FORMATS = {
    reset: '\x1b[0m',
    bright: '\x1b[1m',
    dim: '\x1b[2m',
    underscore: '\x1b[4m',
    blink: '\x1b[5m',
    reverse: '\x1b[7m',
    hidden: '\x1b[8m',
    fg_black: '\x1b[30m',
    fg_red: '\x1b[31m',
    fg_green: '\x1b[32m',
    fg_yellow: '\x1b[33m',
    fg_blue: '\x1b[34m',
    fg_magenta: '\x1b[35m',
    fg_cyan: '\x1b[36m',
    fg_white: '\x1b[37m',
    fg_gray: '\x1b[90m',
    bg_black: '\x1b[40m',
    bg_red: '\x1b[41m',
    bg_green: '\x1b[42m',
    bg_yellow: '\x1b[43m',
    bg_blue: '\x1b[44m',
    bg_magenta: '\x1b[45m',
    bg_cyan: '\x1b[46m',
    bg_white: '\x1b[47m',
    bg_gray: '\x1b[100m',
};
/**
 * Predefined text formats
 */
Term.PREDEFINED_FORMATS = {
    log: 'fg_white',
    debug: 'fg_gray',
    error: 'fg_red',
    warn: 'fg_yellow',
    info: 'fg_cyan',
    success: 'fg_green',
    bg_log: ['bg_blue', 'fg_white'],
    bg_debug: ['bg_gray', 'fg_black'],
    bg_error: ['bg_red', 'fg_white'],
    bg_warn: ['bg_yellow', 'fg_black'],
    bg_info: ['bg_cyan', 'fg_black'],
    bg_success: ['bg_green', 'fg_white'],
};
//TEST TABLE
// const _values: any[] = `
// In eu feugiat ipsum, id euismod nisi.
// Sed sem velit, facilisis vitae turpis ut, ornare finibus lacus.
// Proin sodales vestibulum mauris eu tempor. Cras sit amet vehicula urna.
// Maecenas feugiat varius velit eu egestas. Donec finibus lorem et tempor lobortis.
// Nullam tincidunt posuere nibh, volutpat imperdiet orci rhoncus eu. Vestibulum maximus rutrum erat ac faucibus.
// Mauris vitae tempor velit.
// Curabitur ultricies nunc non massa auctor, vel tincidunt turpis elementum.
// `.trim().split('\n').map(v => v.trim());
// const _set = new Set<number>([1, 2, 2, 4, 5]);
// const _map = new Map<string, any>([['name', 'Martin'], ['age', 30], ['phone', 444555]]);
// const _circ = (()=>{ const xv = {name:'testXV',_get:function(this: any){const self = this; self._xv = self; return self;}}; return xv._get(); })();
// _values.push(...[new Date(), new TypeError('Hello error.'), _set, _map, _circ]);
// const _batch = _batchValues(_values, 3).map(arr => !(_rand(0, 10)%2) ? arr.slice(0) : arr.slice(0).reverse());
// const _objects: any[] = _jsonClone<any[][]>(_batch).map(arr => Object.fromEntries(arr.map((v, i) => [`col ${i}`, v])));
// const _object: any = _objects[_rand(0, _objects.length - 1)];
// const _arr: any[] = [...Array(5)].map((_, r) => [...Array(4)].map((_, c) => `${[r, c]}`));
// //tests
// const _tests: {[key: string]: any} = {
// 	_set,
// 	_map,
// 	_batch,
// 	_object,
// 	_arr,
// 	_str: 'Curabitur ultricies nunc non massa auctor, vel tincidunt turpis elementum.',
// 	_num: _rand(1000, 100000),
// 	_date: new Date(),
// 	_err: new Error('Hello error!'),
// 	_bool: [true, false],
// };
// Object.entries(_tests).forEach((entry, i) => {
// 	const [key, value] = entry;
// 	console.log('');
// 	Term.warn(`--- [${i}] test - ${key}`, value?.length ?? '');
// 	Term.table(value, 32);
// });
// //table
// console.log('');
// Term.debug('=== table');
// console.table(_arr);
// console.table(_object);
// return;


/***/ }),

/***/ "./lib/utils/index.ts":
/*!****************************!*\
  !*** ./lib/utils/index.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._debouced = exports._hasAnyProps = exports._hasProps = exports._hasProp = exports._flatten = exports.ElapsedTime = exports.Term = exports._sortValues = exports._queue = exports._sleep = exports._asyncValues = exports._asyncAll = exports._rand = exports._commas = exports._round = exports._int = exports._num = exports._toNum = exports._isNumeric = exports._timestamp = exports._datetime = exports._getDate = exports._isDate = exports._batchValues = exports._camelCase = exports._studlyCase = exports._slugCase = exports._snakeCase = exports._sentenceCase = exports._titleCase = exports._rtrim = exports._ltrim = exports._trim = exports._strEscape = exports._regEscape = exports._strNorm = exports._str = exports._stringable = exports._string = exports._uuid = exports._jsonClone = exports._jsonParse = exports._jsonStringify = exports._sayHello = void 0;
//_hello
var _hello_1 = __webpack_require__(/*! ./_hello */ "./lib/utils/_hello.ts");
Object.defineProperty(exports, "_sayHello", ({ enumerable: true, get: function () { return _hello_1._sayHello; } }));
//_json
var _json_1 = __webpack_require__(/*! ./_json */ "./lib/utils/_json.ts");
Object.defineProperty(exports, "_jsonStringify", ({ enumerable: true, get: function () { return _json_1._jsonStringify; } }));
Object.defineProperty(exports, "_jsonParse", ({ enumerable: true, get: function () { return _json_1._jsonParse; } }));
Object.defineProperty(exports, "_jsonClone", ({ enumerable: true, get: function () { return _json_1._jsonClone; } }));
//_string
var _string_1 = __webpack_require__(/*! ./_string */ "./lib/utils/_string.ts");
Object.defineProperty(exports, "_uuid", ({ enumerable: true, get: function () { return _string_1._uuid; } }));
Object.defineProperty(exports, "_string", ({ enumerable: true, get: function () { return _string_1._string; } }));
Object.defineProperty(exports, "_stringable", ({ enumerable: true, get: function () { return _string_1._stringable; } }));
Object.defineProperty(exports, "_str", ({ enumerable: true, get: function () { return _string_1._str; } }));
Object.defineProperty(exports, "_strNorm", ({ enumerable: true, get: function () { return _string_1._strNorm; } }));
Object.defineProperty(exports, "_regEscape", ({ enumerable: true, get: function () { return _string_1._regEscape; } }));
Object.defineProperty(exports, "_strEscape", ({ enumerable: true, get: function () { return _string_1._strEscape; } }));
Object.defineProperty(exports, "_trim", ({ enumerable: true, get: function () { return _string_1._trim; } }));
Object.defineProperty(exports, "_ltrim", ({ enumerable: true, get: function () { return _string_1._ltrim; } }));
Object.defineProperty(exports, "_rtrim", ({ enumerable: true, get: function () { return _string_1._rtrim; } }));
Object.defineProperty(exports, "_titleCase", ({ enumerable: true, get: function () { return _string_1._titleCase; } }));
Object.defineProperty(exports, "_sentenceCase", ({ enumerable: true, get: function () { return _string_1._sentenceCase; } }));
Object.defineProperty(exports, "_snakeCase", ({ enumerable: true, get: function () { return _string_1._snakeCase; } }));
Object.defineProperty(exports, "_slugCase", ({ enumerable: true, get: function () { return _string_1._slugCase; } }));
Object.defineProperty(exports, "_studlyCase", ({ enumerable: true, get: function () { return _string_1._studlyCase; } }));
Object.defineProperty(exports, "_camelCase", ({ enumerable: true, get: function () { return _string_1._camelCase; } }));
//_batch
var _batch_1 = __webpack_require__(/*! ./_batch */ "./lib/utils/_batch.ts");
Object.defineProperty(exports, "_batchValues", ({ enumerable: true, get: function () { return _batch_1._batchValues; } }));
//_datetime
var _datetime_1 = __webpack_require__(/*! ./_datetime */ "./lib/utils/_datetime.ts");
Object.defineProperty(exports, "_isDate", ({ enumerable: true, get: function () { return _datetime_1._isDate; } }));
Object.defineProperty(exports, "_getDate", ({ enumerable: true, get: function () { return _datetime_1._getDate; } }));
Object.defineProperty(exports, "_datetime", ({ enumerable: true, get: function () { return _datetime_1._datetime; } }));
Object.defineProperty(exports, "_timestamp", ({ enumerable: true, get: function () { return _datetime_1._timestamp; } }));
var _number_1 = __webpack_require__(/*! ./_number */ "./lib/utils/_number.ts");
Object.defineProperty(exports, "_isNumeric", ({ enumerable: true, get: function () { return _number_1._isNumeric; } }));
Object.defineProperty(exports, "_toNum", ({ enumerable: true, get: function () { return _number_1._toNum; } }));
Object.defineProperty(exports, "_num", ({ enumerable: true, get: function () { return _number_1._num; } }));
Object.defineProperty(exports, "_int", ({ enumerable: true, get: function () { return _number_1._int; } }));
Object.defineProperty(exports, "_round", ({ enumerable: true, get: function () { return _number_1._round; } }));
Object.defineProperty(exports, "_commas", ({ enumerable: true, get: function () { return _number_1._commas; } }));
Object.defineProperty(exports, "_rand", ({ enumerable: true, get: function () { return _number_1._rand; } }));
var _promise_1 = __webpack_require__(/*! ./_promise */ "./lib/utils/_promise.ts");
Object.defineProperty(exports, "_asyncAll", ({ enumerable: true, get: function () { return _promise_1._asyncAll; } }));
Object.defineProperty(exports, "_asyncValues", ({ enumerable: true, get: function () { return _promise_1._asyncValues; } }));
Object.defineProperty(exports, "_sleep", ({ enumerable: true, get: function () { return _promise_1._sleep; } }));
var _queue_1 = __webpack_require__(/*! ./_queue */ "./lib/utils/_queue.ts");
Object.defineProperty(exports, "_queue", ({ enumerable: true, get: function () { return _queue_1._queue; } }));
var _sort_1 = __webpack_require__(/*! ./_sort */ "./lib/utils/_sort.ts");
Object.defineProperty(exports, "_sortValues", ({ enumerable: true, get: function () { return _sort_1._sortValues; } }));
var _term_1 = __webpack_require__(/*! ./_term */ "./lib/utils/_term.ts");
Object.defineProperty(exports, "Term", ({ enumerable: true, get: function () { return _term_1.Term; } }));
//_ElapsedTime
var _ElapsedTime_1 = __webpack_require__(/*! ./_ElapsedTime */ "./lib/utils/_ElapsedTime.ts");
Object.defineProperty(exports, "ElapsedTime", ({ enumerable: true, get: function () { return _ElapsedTime_1.ElapsedTime; } }));
//_objects
var _objects_1 = __webpack_require__(/*! ./_objects */ "./lib/utils/_objects.ts");
Object.defineProperty(exports, "_flatten", ({ enumerable: true, get: function () { return _objects_1._flatten; } }));
Object.defineProperty(exports, "_hasProp", ({ enumerable: true, get: function () { return _objects_1._hasProp; } }));
Object.defineProperty(exports, "_hasProps", ({ enumerable: true, get: function () { return _objects_1._hasProps; } }));
Object.defineProperty(exports, "_hasAnyProps", ({ enumerable: true, get: function () { return _objects_1._hasAnyProps; } }));
//_debounced
var _debouced_1 = __webpack_require__(/*! ./_debouced */ "./lib/utils/_debouced.ts");
Object.defineProperty(exports, "_debouced", ({ enumerable: true, get: function () { return _debouced_1._debouced; } }));


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./lib/index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtVQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veHV0aWxzL3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2s6Ly94dXRpbHMvLi9saWIvaW5kZXgudHMiLCJ3ZWJwYWNrOi8veHV0aWxzLy4vbGliL3V0aWxzL19FbGFwc2VkVGltZS50cyIsIndlYnBhY2s6Ly94dXRpbHMvLi9saWIvdXRpbHMvX2JhdGNoLnRzIiwid2VicGFjazovL3h1dGlscy8uL2xpYi91dGlscy9fZGF0ZXRpbWUudHMiLCJ3ZWJwYWNrOi8veHV0aWxzLy4vbGliL3V0aWxzL19kZWJvdWNlZC50cyIsIndlYnBhY2s6Ly94dXRpbHMvLi9saWIvdXRpbHMvX2hlbGxvLnRzIiwid2VicGFjazovL3h1dGlscy8uL2xpYi91dGlscy9fanNvbi50cyIsIndlYnBhY2s6Ly94dXRpbHMvLi9saWIvdXRpbHMvX251bWJlci50cyIsIndlYnBhY2s6Ly94dXRpbHMvLi9saWIvdXRpbHMvX29iamVjdHMudHMiLCJ3ZWJwYWNrOi8veHV0aWxzLy4vbGliL3V0aWxzL19wcm9taXNlLnRzIiwid2VicGFjazovL3h1dGlscy8uL2xpYi91dGlscy9fcXVldWUudHMiLCJ3ZWJwYWNrOi8veHV0aWxzLy4vbGliL3V0aWxzL19zb3J0LnRzIiwid2VicGFjazovL3h1dGlscy8uL2xpYi91dGlscy9fc3RyaW5nLnRzIiwid2VicGFjazovL3h1dGlscy8uL2xpYi91dGlscy9fdGVybS50cyIsIndlYnBhY2s6Ly94dXRpbHMvLi9saWIvdXRpbHMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8veHV0aWxzL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL3h1dGlscy93ZWJwYWNrL2JlZm9yZS1zdGFydHVwIiwid2VicGFjazovL3h1dGlscy93ZWJwYWNrL3N0YXJ0dXAiLCJ3ZWJwYWNrOi8veHV0aWxzL3dlYnBhY2svYWZ0ZXItc3RhcnR1cCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJ4dXRpbHNcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wieHV0aWxzXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgKCkgPT4ge1xucmV0dXJuICIsImV4cG9ydCAqIGZyb20gJy4vdXRpbHMnOyIsImltcG9ydCB7IF9pc0RhdGUgfSBmcm9tICcuL19kYXRldGltZSc7XHJcbmltcG9ydCB7IF9yb3VuZCB9IGZyb20gJy4vX251bWJlcic7XHJcblxyXG5leHBvcnQgY2xhc3MgRWxhcHNlZFRpbWVcclxue1xyXG5cdC8vcHJvcHNcclxuXHRzdGFydF90aW1lOiBEYXRlfHVuZGVmaW5lZDtcclxuXHRzdG9wX3RpbWU6IERhdGV8dW5kZWZpbmVkO1xyXG5cdF9tczogbnVtYmVyfHVuZGVmaW5lZDtcclxuXHRcclxuXHQvKipcclxuXHQgKiBOZXcgaW5zdGFuY2VcclxuXHQgKi9cclxuXHRjb25zdHJ1Y3Rvcigpe1xyXG5cdFx0dGhpcy5zdGFydF90aW1lID0gbmV3IERhdGUoKTtcclxuXHRcdHRoaXMuc3RvcF90aW1lID0gdW5kZWZpbmVkO1xyXG5cdFx0dGhpcy5fbXMgPSB1bmRlZmluZWQ7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTdGFydCB0aW1lIHRyYWNraW5nIChzZXRzIHN0YXJ0X3RpbWUgdG8gbm93IGFuZCByZXNldHMgb3RoZXIgcHJvcGVydGllcylcclxuXHQgKi9cclxuXHRzdGFydCgpOiBFbGFwc2VkVGltZSB7XHJcblx0XHRjb25zdCBfbm93ID0gbmV3IERhdGUoKTtcclxuXHRcdHRoaXMuc3RhcnRfdGltZSA9IF9pc0RhdGUodGhpcy5zdGFydF90aW1lKSA/IHRoaXMuc3RhcnRfdGltZSA6IF9ub3c7XHJcblx0XHR0aGlzLnN0b3BfdGltZSA9IHVuZGVmaW5lZDtcclxuXHRcdHRoaXMuX21zID0gdW5kZWZpbmVkO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUcmFjayBjdXJyZW50IHRpbWUgKHNldHMgdGhpcy5fbXMgdG8gdGltZSBkaWZmZXJlbmNlIGJldHdlZW4gbGFzdCBzdGFydCBhbmQgbm93KVxyXG5cdCAqIFxyXG5cdCAqIEBwYXJhbSB1cGRhdGVTdGFydCAgU2V0IHN0YXJ0IHRvIG5vd1xyXG5cdCAqL1xyXG5cdG5vdyh1cGRhdGVTdGFydDogYm9vbGVhbiA9IGZhbHNlKTogRWxhcHNlZFRpbWUge1xyXG5cdFx0Y29uc3QgX25vdyA9IG5ldyBEYXRlKCk7XHJcblx0XHRjb25zdCBfc3RhcnQ6IGFueSA9IF9pc0RhdGUodGhpcy5zdGFydF90aW1lKSA/IHRoaXMuc3RhcnRfdGltZSA6IHRoaXMuc3RhcnRfdGltZSA9IF9ub3c7XHJcblx0XHR0aGlzLl9tcyA9IF9ub3cuZ2V0VGltZSgpIC0gX3N0YXJ0LmdldFRpbWUoKTtcclxuXHRcdGlmICh1cGRhdGVTdGFydCkgdGhpcy5zdGFydF90aW1lID0gX25vdztcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU3RvcCB0aW1lIHRyYWNraW5nIChzZXRzIHRoaXMuX21zIHRvIHRpbWUgZGlmZmVyZW5jZSBiZXR3ZWVuIGxhc3Qgc3RhcnQgYW5kIGxhc3Qgc3RvcClcclxuXHQgKiBJZiBsYXN0IHN0b3AgaXMgbGVzcyB0aGFuIHN0YXJ0IHRpbWUsIHN0b3AgdGltZSBpcyB1cGRhdGVkIHRvIG5vdy5cclxuXHQgKi9cclxuXHRzdG9wKCk6IEVsYXBzZWRUaW1lIHtcclxuXHRcdGNvbnN0IF9ub3cgPSBuZXcgRGF0ZSgpO1xyXG5cdFx0Y29uc3QgX3N0YXJ0OiBhbnkgPSBfaXNEYXRlKHRoaXMuc3RhcnRfdGltZSkgPyB0aGlzLnN0YXJ0X3RpbWUgOiBfbm93LCB0ID0gX3N0YXJ0LmdldFRpbWUoKTtcclxuXHRcdGNvbnN0IF9zdG9wX3RpbWU6IGFueSA9IHRoaXMuc3RvcF90aW1lO1xyXG5cdFx0Y29uc3QgX3N0b3AgPSBfaXNEYXRlKF9zdG9wX3RpbWUpICYmIF9zdG9wX3RpbWUuZ2V0VGltZSgpID49IHQgPyBfc3RvcF90aW1lIDogdGhpcy5zdG9wX3RpbWUgPSBfbm93O1xyXG5cdFx0dGhpcy5fbXMgPSBfc3RvcC5nZXRUaW1lKCkgLSB0O1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBXaGV0aGVyIHRpbWUgdHJhY2tpbmcgd2FzIHN0YXJ0ZWRcclxuXHQgKi9cclxuXHRzdGFydGVkKCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIF9pc0RhdGUodGhpcy5zdGFydF90aW1lKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFdoZXRoZXIgdGltZSB0cmFja2luZyB3YXMgc3RvcHBlZFxyXG5cdCAqL1xyXG5cdHN0b3BwZWQoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gX2lzRGF0ZSh0aGlzLnN0b3BfdGltZSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdHJhY2tlZCBlbGFwc2VkIHRpbWUgaW4gbWlsbGlzZWNvbmRzXHJcblx0ICogXHJcblx0ICogQHJldHVybnMgbWlsbGlzZWNvbmRzXHJcblx0ICovXHJcblx0bXMoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiBwYXJzZUludCh0aGlzLl9tcyBhcyBhbnkpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRyYWNrZWQgZWxhcHNlZCB0aW1lIGluIHNlY29uZHNcclxuXHQgKiBcclxuXHQgKiBAcGFyYW0gZGVjaW1hbFBsYWNlc1xyXG5cdCAqIEByZXR1cm5zIHNlY29uZHNcclxuXHQgKi9cclxuXHRzZWMoZGVjaW1hbFBsYWNlczogbnVtYmVyID0gMyk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gX3JvdW5kKHRoaXMubXMoKS8xMDAwLCBkZWNpbWFsUGxhY2VzKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0cmFja2VkIGVsYXBzZWQgdGltZSBpbiBtaW51dGVzXHJcblx0ICogXHJcblx0ICogQHBhcmFtIGRlY2ltYWxQbGFjZXNcclxuXHQgKiBAcmV0dXJucyBtaW51dGVzXHJcblx0ICovXHJcblx0bWluKGRlY2ltYWxQbGFjZXM6IG51bWJlciA9IDMpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIF9yb3VuZCh0aGlzLm1zKCkvNjAwMDAsIGRlY2ltYWxQbGFjZXMpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRyYWNraW5nIGRhdGEgKHRoaXMgd2lsbCBzdG9wIHRyYWNraW5nKVxyXG5cdCAqL1xyXG5cdGRhdGEoKToge3N0YXJ0X3RpbWU6IERhdGV8dW5kZWZpbmVkOyBzdG9wX3RpbWU6IERhdGV8dW5kZWZpbmVkOyBlbGFwc2VkX21zOiBudW1iZXI7fXtcclxuXHRcdHRoaXMuc3RvcCgpO1xyXG5cdFx0Y29uc3Qgc3RhcnRfdGltZSA9IF9pc0RhdGUodGhpcy5zdGFydF90aW1lKSA/IHRoaXMuc3RhcnRfdGltZSA6IHVuZGVmaW5lZDtcclxuXHRcdGNvbnN0IHN0b3BfdGltZSA9IF9pc0RhdGUodGhpcy5zdG9wX3RpbWUpID8gdGhpcy5zdG9wX3RpbWUgOiB1bmRlZmluZWQ7XHJcblx0XHRjb25zdCBlbGFwc2VkX21zID0gdGhpcy5tcygpO1xyXG5cdFx0cmV0dXJuIHtzdGFydF90aW1lLCBzdG9wX3RpbWUsIGVsYXBzZWRfbXN9O1xyXG5cdH1cclxufSIsIi8qKlxyXG4gKiBTcGxpdCBgYXJyYXlgIGludG8gYmF0Y2hlcyBgVFtdW11gIG9mIHNwZWNpZmllZCBzaXplLlxyXG4gKiAtIGkuZS4gYF9iYXRjaFZhbHVlczxudW1iZXI+KFsxLDIsMyw0LDUsNiw3LDhdLCAzKWAgPT4gYFtbMSwyLDNdLFs0LDUsNl0sWzcsOF1dYFxyXG4gKiBcclxuICogQHBhcmFtIGFycmF5ICBCYXRjaCB2YWx1ZXNcclxuICogQHBhcmFtIGJhdGNoU2l6ZSAgQmF0Y2ggc2l6ZSBgeCA+IDBgLlxyXG4gKiBAcmV0dXJucyAgYFRbXVtdYFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IF9iYXRjaFZhbHVlcyA9IDxUIGV4dGVuZHMgYW55PihhcnJheTogVFtdLCBiYXRjaFNpemU6IG51bWJlcik6IFRbXVtdID0+IHtcclxuXHRpZiAoIShOdW1iZXIuaXNJbnRlZ2VyKGJhdGNoU2l6ZSkgJiYgYmF0Y2hTaXplID4gMCkpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBiYXRjaCBzaXplLicpO1xyXG5cdGNvbnN0IF9hcnJheSA9IGFycmF5LnNsaWNlKDApLCBfYnVmZmVyOiBUW11bXSA9IFtdO1xyXG5cdHdoaWxlIChfYXJyYXkubGVuZ3RoKSBfYnVmZmVyLnB1c2goX2FycmF5LnNwbGljZSgwLCBiYXRjaFNpemUpKTtcclxuXHRyZXR1cm4gX2J1ZmZlcjtcclxufTsiLCIvKipcclxuICogVmFsaWRhdGUgYERhdGVgIGluc3RhbmNlXHJcbiAqIFxyXG4gKiBAcGFyYW0gdmFsdWVcclxuICovXHJcbmV4cG9ydCBjb25zdCBfaXNEYXRlID0gKHZhbHVlOiBhbnkpOiBib29sZWFuID0+IHZhbHVlIGluc3RhbmNlb2YgRGF0ZSAmJiAhaXNOYU4odmFsdWUuZ2V0VGltZSgpKTtcclxuXHJcbi8qKlxyXG4gKiBHZXQvY3JlYXRlIGBEYXRlYCBpbnN0YW5jZVxyXG4gKiBcclxuICogQHBhcmFtIHZhbHVlICBQYXJzZSB2YWx1ZSB+IGB2YWx1ZSBpbnN0YW5jZU9mIERhdGUgPyB2YWx1ZSA6IG5ldyBEYXRlKHZhbHVlKWBcclxuICogQHBhcmFtIF9kZWZhdWx0ICBQYXJzZSBkZWZhdWx0IG9uIGZhaWx1cmUgW2RlZmF1bHQ6IGB1bmRlZmluZWRgID0+IGBuZXcgRGF0ZSgpYF1cclxuICovXHJcbmV4cG9ydCBjb25zdCBfZ2V0RGF0ZSA9ICh2YWx1ZT86IGFueSwgX2RlZmF1bHQ/OiBEYXRlfHN0cmluZ3xudW1iZXJ8bnVsbHx1bmRlZmluZWQpOiBEYXRlID0+IHtcclxuXHRpZiAoIV9pc0RhdGUodmFsdWUpICYmICFfaXNEYXRlKHZhbHVlID0gbmV3IERhdGUodmFsdWUpKSl7XHJcblx0XHRpZiAoX2RlZmF1bHQgaW5zdGFuY2VvZiBEYXRlKSB2YWx1ZSA9IF9kZWZhdWx0O1xyXG5cdFx0ZWxzZSBpZiAoX2RlZmF1bHQgPT09IHVuZGVmaW5lZCkgdmFsdWUgPSBuZXcgRGF0ZSgpO1xyXG5cdFx0ZWxzZSB2YWx1ZSA9IG5ldyBEYXRlKF9kZWZhdWx0IGFzIGFueSk7XHJcblx0fVxyXG5cdHJldHVybiB2YWx1ZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0IGBEYXRlYCB2YWx1ZSB0byBkYXRldGltZSBmb3JtYXQgKGkuZS4gYDIwMjMtMDUtMjcgMjI6MTE6NTdgIH4gYFlZWVktTU0tREQgSEg6bW06c3NgKVxyXG4gKiBcclxuICogQHBhcmFtIHZhbHVlICBQYXJzZSB2YWx1ZSB+IGB2YWx1ZSBpbnN0YW5jZU9mIERhdGUgPyB2YWx1ZSA6IG5ldyBEYXRlKHZhbHVlKWBcclxuICogQHBhcmFtIF9kZWZhdWx0ICBQYXJzZSBkZWZhdWx0IG9uIGZhaWx1cmUgW2RlZmF1bHQ6IGB1bmRlZmluZWRgID0+IGBuZXcgRGF0ZSgpYF1cclxuICovXHJcbmV4cG9ydCBjb25zdCBfZGF0ZXRpbWUgPSAodmFsdWU/OiBhbnksIF9kZWZhdWx0PzogRGF0ZXxzdHJpbmd8bnVtYmVyfG51bGx8dW5kZWZpbmVkKTogc3RyaW5nID0+IHtcclxuXHRjb25zdCBkYXRlID0gX2dldERhdGUodmFsdWUsIF9kZWZhdWx0KSwgX3BhZCA9ICh2OiBudW1iZXIpID0+IGAke3Z9YC5wYWRTdGFydCgyLCAnMCcpO1xyXG5cdHJldHVybiAhX2lzRGF0ZShkYXRlKSA/IGAke2RhdGV9YCA6IGAke2RhdGUuZ2V0RnVsbFllYXIoKX0tJHtfcGFkKGRhdGUuZ2V0TW9udGgoKSArIDEpfS0ke19wYWQoZGF0ZS5nZXREYXRlKCkpfSAke19wYWQoZGF0ZS5nZXRIb3VycygpKX06JHtfcGFkKGRhdGUuZ2V0TWludXRlcygpKX06JHtfcGFkKGRhdGUuZ2V0U2Vjb25kcygpKX1gO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgYERhdGVgIHZhbHVlIHRvIElTTyBmb3JtYXQgKGkuZS4gYG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKWAgfiBgMjAyMy0wNS0yN1QxOTozMDo0NC41NzVaYClcclxuICogXHJcbiAqIEBwYXJhbSB2YWx1ZSAgUGFyc2UgdmFsdWUgfiBgdmFsdWUgaW5zdGFuY2VPZiBEYXRlID8gdmFsdWUgOiBuZXcgRGF0ZSh2YWx1ZSlgXHJcbiAqIEBwYXJhbSBfZGVmYXVsdCAgUGFyc2UgZGVmYXVsdCBvbiBmYWlsdXJlIFtkZWZhdWx0OiBgdW5kZWZpbmVkYCA9PiBgbmV3IERhdGUoKWBdXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgX3RpbWVzdGFtcCA9ICh2YWx1ZT86IGFueSwgX2RlZmF1bHQ/OiBEYXRlfHN0cmluZ3xudW1iZXJ8bnVsbHx1bmRlZmluZWQpOiBzdHJpbmcgPT4ge1xyXG5cdGNvbnN0IGRhdGUgPSBfZ2V0RGF0ZSh2YWx1ZSwgX2RlZmF1bHQpO1xyXG5cdHJldHVybiAhX2lzRGF0ZShkYXRlKSA/IGAke2RhdGV9YCA6IGRhdGUudG9JU09TdHJpbmcoKTtcclxufTtcclxuXHJcbi8vLi5cclxuXHJcbi8qXHJcbi8vVEVTVFM6XHJcbmNvbnNvbGUubG9nKGBfZ2V0RGF0ZSgpID0+IG5ldyBEYXRlKCkgPT5gLCBfZ2V0RGF0ZSgpKTtcclxuY29uc29sZS5sb2coYF9nZXREYXRlKCcyMDIzLTA1LTI3VDE5OjMwOjQ0LjU3NVonKSA9PmAsIF9nZXREYXRlKCcyMDIzLTA1LTI3VDE5OjMwOjQ0LjU3NVonKSk7XHJcbmNvbnNvbGUubG9nKGBfZ2V0RGF0ZSgxNjg1MjE1ODQ0NTc1KSA9PmAsIF9nZXREYXRlKDE2ODUyMTU4NDQ1NzUpKTtcclxuY29uc29sZS5sb2coYF9nZXREYXRlKE5hTikgPT4gbmV3IERhdGUoKSA9PmAsIF9nZXREYXRlKE5hTikpO1xyXG5jb25zb2xlLmxvZyhgX2dldERhdGUoTmFOLCBudWxsKSA9PiBgLCBfZ2V0RGF0ZShOYU4sIG51bGwpKTtcclxuY29uc29sZS5sb2coYF9nZXREYXRlKE5hTiwgbmV3IERhdGUoKSkgPT4gYCwgX2dldERhdGUoTmFOLCBuZXcgRGF0ZSgpKSk7XHJcbmNvbnNvbGUubG9nKGBfZ2V0RGF0ZShOYU4sIE5hTikgPT4gYCwgX2dldERhdGUoTmFOLCBOYU4pKTtcclxuY29uc29sZS5sb2coYF9nZXREYXRlKE5hTiwgMTY4NTIxNTg0NDU3NSkgPT4gYCwgX2dldERhdGUoTmFOLCAxNjg1MjE1ODQ0NTc1KSk7XHJcbmNvbnNvbGUubG9nKGBfZ2V0RGF0ZShOYU4sICcyMDIzLTA1LTI3VDE5OjMwOjQ0LjU3NVonKSA9PiBgLCBfZ2V0RGF0ZShOYU4sICcyMDIzLTA1LTI3VDE5OjMwOjQ0LjU3NVonKSk7XHJcbmNvbnNvbGUubG9nKGBfZ2V0RGF0ZShOYU4sICdtaWRuaWdodCcpID0+IGAsIF9nZXREYXRlKE5hTiwgJ21pZG5pZ2h0JykpO1xyXG5cclxuLy9SRVNVTFRTOlxyXG4vLyBfZ2V0RGF0ZSgpID0+IG5ldyBEYXRlKCkgPT4gMjAyMy0wNS0yN1QyMDozOToxOS44MjFaXHJcbi8vIF9nZXREYXRlKCcyMDIzLTA1LTI3VDE5OjMwOjQ0LjU3NVonKSA9PiAyMDIzLTA1LTI3VDE5OjMwOjQ0LjU3NVpcclxuLy8gX2dldERhdGUoMTY4NTIxNTg0NDU3NSkgPT4gMjAyMy0wNS0yN1QxOTozMDo0NC41NzVaXHJcbi8vIF9nZXREYXRlKE5hTikgPT4gbmV3IERhdGUoKSA9PiAyMDIzLTA1LTI3VDIwOjM5OjE5LjgyM1pcclxuLy8gX2dldERhdGUoTmFOLCBudWxsKSA9PiAgMTk3MC0wMS0wMVQwMDowMDowMC4wMDBaXHJcbi8vIF9nZXREYXRlKE5hTiwgbmV3IERhdGUoKSkgPT4gIDIwMjMtMDUtMjdUMjA6Mzk6MTkuODI0WlxyXG4vLyBfZ2V0RGF0ZShOYU4sIE5hTikgPT4gIEludmFsaWQgRGF0ZVxyXG4vLyBfZ2V0RGF0ZShOYU4sIDE2ODUyMTU4NDQ1NzUpID0+ICAyMDIzLTA1LTI3VDE5OjMwOjQ0LjU3NVpcclxuLy8gX2dldERhdGUoTmFOLCAnMjAyMy0wNS0yN1QxOTozMDo0NC41NzVaJykgPT4gIDIwMjMtMDUtMjdUMTk6MzA6NDQuNTc1WlxyXG4vLyBfZ2V0RGF0ZShOYU4sICdtaWRuaWdodCcpID0+ICBJbnZhbGlkIERhdGVcclxuKi8iLCJpbXBvcnQgeyBib29sIH0gZnJvbSAnLi9fY29tbW9uJztcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGUgZGVib3VuY2VkIGNhbGxiYWNrIGZ1bmN0aW9uXHJcbiAqIFxyXG4gKiBAcGFyYW0gaGFuZGxlciAgVGhyb3R0bGVkIGNhbGxiYWNrIGhhbmRsZXJcclxuICogQHBhcmFtIGRlbGF5ICBDYWxsYmFjayBkZWxheSBtaWxsaXNlY29uZHNcclxuICogQHBhcmFtIG1heFdhaXQgIE1heGltdW0gY2FsbGJhY2sgZGVsYXkgbWlsbGlzZWNvbmRzXHJcbiAqIEBwYXJhbSBpbW1lZGlhdGUgIEV4ZWN1dGUgY2FsbGJhY2sgYmVmb3JlIGRlbGF5XHJcbiAqIEByZXR1cm5zIFRocm90dGxlZCBjYWxsYmFjayBmdW5jdGlvblxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IF9kZWJvdWNlZCA9IChoYW5kbGVyOiAoLi4uYXJnczogYW55KT0+dm9pZCwgZGVsYXk6IG51bWJlciA9IDIwMCwgbWF4V2FpdDogbnVtYmVyID0gMCwgaW1tZWRpYXRlOiBib29sID0gZmFsc2UpOiAoKC4uLmFyZ3M6IGFueSk9PnZvaWQpID0+IHtcclxuXHRkZWxheSA9ICFpc05hTihkZWxheSA9IHBhcnNlRmxvYXQoZGVsYXkgYXMgYW55KSkgJiYgZGVsYXkgPj0gMCA/IGRlbGF5IDogMjAwO1xyXG5cdG1heFdhaXQgPSAhaXNOYU4obWF4V2FpdCA9IHBhcnNlRmxvYXQobWF4V2FpdCBhcyBhbnkpKSAmJiBtYXhXYWl0ID49IDAgJiYgbWF4V2FpdCA+IGRlbGF5ID8gbWF4V2FpdCA6IDA7XHJcblx0aW1tZWRpYXRlID0gISFpbW1lZGlhdGU7XHJcblx0bGV0IGltbWVkaWF0ZVRpbWVyOiBhbnksIGNhbGxUaW1lcjogYW55LCB3YWl0VGltZXI6IGFueSwgbmV4dENhbGw6IFtjb250ZXh0OiBhbnksIGFyZ3M6IGFueVtdXSB8IHVuZGVmaW5lZDtcclxuXHRjb25zdCBleGVjdXRlID0gKGlzX2ltbWVkaWF0ZT86Ym9vbCkgPT4ge1xyXG5cdFx0bGV0IG5leHQgPSBuZXh0Q2FsbDtcclxuXHRcdG5leHRDYWxsID0gdW5kZWZpbmVkO1xyXG5cdFx0aWYgKHdhaXRUaW1lcil7XHJcblx0XHRcdGNsZWFyVGltZW91dCh3YWl0VGltZXIpO1xyXG5cdFx0XHR3YWl0VGltZXIgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblx0XHRpZiAoY2FsbFRpbWVyICYmICFpc19pbW1lZGlhdGUpe1xyXG5cdFx0XHRjbGVhclRpbWVvdXQoY2FsbFRpbWVyKTtcclxuXHRcdFx0Y2FsbFRpbWVyID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cdFx0aWYgKG5leHQ/Lmxlbmd0aCAmJiAnZnVuY3Rpb24nID09PSB0eXBlb2YgaGFuZGxlcikgaGFuZGxlci5hcHBseSguLi5uZXh0KTtcclxuXHRcdGlmIChkZWxheSAmJiBpbW1lZGlhdGUgJiYgIWlzX2ltbWVkaWF0ZSl7XHJcblx0XHRcdGltbWVkaWF0ZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XHJcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KGltbWVkaWF0ZVRpbWVyKTtcclxuXHRcdFx0XHRpbW1lZGlhdGVUaW1lciA9IHVuZGVmaW5lZDtcclxuXHRcdFx0fSwgZGVsYXkpO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0Y29uc3Qgd3JhcHBlciA9IGZ1bmN0aW9uKHRoaXM6IGFueSwgLi4uYXJnczogYW55W10pe1xyXG5cdFx0bmV4dENhbGwgPSBbdGhpcywgYXJnc107XHJcblx0XHRpZiAoIWRlbGF5KSByZXR1cm4gZXhlY3V0ZSgpO1xyXG5cdFx0Y29uc3QgX25leHQgPSAobm9fd2FpdD0wKSA9PiB7XHJcblx0XHRcdGNsZWFyVGltZW91dChjYWxsVGltZXIpO1xyXG5cdFx0XHRjYWxsVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IGV4ZWN1dGUoKSwgZGVsYXkpO1xyXG5cdFx0XHRpZiAoIW5vX3dhaXQgJiYgbWF4V2FpdCAmJiAhd2FpdFRpbWVyKSB3YWl0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IGV4ZWN1dGUoKSwgbWF4V2FpdCk7XHJcblx0XHR9O1xyXG5cdFx0aWYgKCEoaW1tZWRpYXRlICYmICFpbW1lZGlhdGVUaW1lciAmJiAhY2FsbFRpbWVyKSkgcmV0dXJuIF9uZXh0KCk7XHJcblx0XHRfbmV4dCgxKVxyXG5cdFx0ZXhlY3V0ZSgxKTtcclxuXHR9O1xyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHdyYXBwZXIsIHtcclxuXHRcdGxlbmd0aDoge3ZhbHVlOiBoYW5kbGVyLmxlbmd0aH0sXHJcblx0XHRuYW1lOiB7dmFsdWU6IGAke2hhbmRsZXIubmFtZXx8J2Fub255bW91cyd9X19kZWJvdW5jZWRfXyR7ZGVsYXl9YH0sXHJcblx0fSk7XHJcblx0cmV0dXJuIHdyYXBwZXI7XHJcbn07IiwiLyoqXHJcbiAqIFNheSBIZWxsbyFcclxuICogXHJcbiAqIEBwYXJhbSBuYW1lXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgX3NheUhlbGxvID0gKG5hbWU/OiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xyXG5cdG5hbWUgPSBuYW1lPy5sZW5ndGggPyBuYW1lIDogJ1RodWt1JztcclxuXHRjb25zdCBoZWxsbyA9IGBbeF0gLSBIZWxsbyAke25hbWV9IWA7XHJcblx0Y29uc29sZS5sb2coaGVsbG8pO1xyXG5cdHJldHVybiBoZWxsbztcclxufSIsIi8qKlxyXG4gKiBDdXN0b20gYEpTT04uc3RyaW5naWZ5YCB3aXRoIGV4dGVuZGVkIGN1c3RvbSByZXBsYWNlclxyXG4gKiAtIERlZmF1bHQgdmFsdWUgZm9yIGB1bmRlZmluZWRgIHZhbHVlIGFyZ3VtZW50XHJcbiAqIC0gRml4IGBFcnJvcmAsIGBTZXRgLCBgTWFwYCBzdHJpbmdpZnlcclxuICogLSBDaXJjdWxhciByZWZlcmVuY2UgZml4ZXNcclxuICogXHJcbiAqIEBwYXJhbSB2YWx1ZSAgUGFyc2UgdmFsdWUgKGB1bmRlZmluZWRgIHZhbHVlIGlzIHJlcGxhY2VkIHdpdGggYF91bmRlZmluZWRgIGFyZ3VtZW50IHN1YnN0aXR1dGUgdmFsdWUpXHJcbiAqIEBwYXJhbSBzcGFjZSAgSW5kZW50YXRpb24gc3BhY2VcclxuICogQHBhcmFtIF91bmRlZmluZWQgIERlZmF1bHQgYHVuZGVmaW5lZGAgYXJndW1lbnQgYHZhbHVlYCBzdWJzdGl0dXRlIChkZWZhdWx0IGBudWxsYClcclxuICogQHJldHVybnNcclxuICovXHJcbmV4cG9ydCBjb25zdCBfanNvblN0cmluZ2lmeSA9ICh2YWx1ZTogYW55LCBzcGFjZT86IHN0cmluZ3xudW1iZXJ8bnVsbHx1bmRlZmluZWQsIF91bmRlZmluZWQ6IGFueSA9IG51bGwpOiBzdHJpbmcgPT4ge1xyXG5cdGNvbnN0IF9zcGFjZTogc3RyaW5nfG51bWJlcnx1bmRlZmluZWQgPSBzcGFjZSA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IHNwYWNlO1xyXG5cdGNvbnN0IHBhcmVudHM6IGFueSA9IFtdO1xyXG5cdGNvbnN0IHBhdGg6IGFueVtdID0gWyd0aGlzJ107XHJcblx0Y29uc3QgcmVmcyA9IG5ldyBNYXA8YW55LCBhbnk+KCk7XHJcblx0Y29uc3QgX2NsZWFyID0gKCk6IHZvaWQgPT4ge1xyXG5cdFx0cmVmcy5jbGVhcigpO1xyXG5cdFx0cGFyZW50cy5sZW5ndGggPSAwO1xyXG5cdFx0cGF0aC5sZW5ndGggPSAxO1xyXG5cdH07XHJcblx0Y29uc3QgX3BhcmVudHMgPSAoa2V5OiBhbnksIHZhbHVlOiBhbnkpOiB2b2lkID0+IHtcclxuXHRcdGxldCBpID0gcGFyZW50cy5sZW5ndGggLSAxLCBwcmV2ID0gcGFyZW50c1tpXTtcclxuXHRcdGlmIChwcmV2W2tleV0gPT09IHZhbHVlIHx8IGkgPT09IDApe1xyXG5cdFx0XHRwYXRoLnB1c2goa2V5KTtcclxuXHRcdFx0cGFyZW50cy5wdXNoKHZhbHVlKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0d2hpbGUgKGktLSA+PSAwKSB7XHJcblx0XHRcdHByZXYgPSBwYXJlbnRzW2ldO1xyXG5cdFx0XHRpZiAocHJldj8uW2tleV0gPT09IHZhbHVlKXtcclxuXHRcdFx0XHRpICs9IDI7XHJcblx0XHRcdFx0cGFyZW50cy5sZW5ndGggPSBpO1xyXG5cdFx0XHRcdHBhdGgubGVuZ3RoID0gaTtcclxuXHRcdFx0XHQtLWk7XHJcblx0XHRcdFx0cGFyZW50c1tpXSA9IHZhbHVlO1xyXG5cdFx0XHRcdHBhdGhbaV0gPSBrZXk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cdGNvbnN0IF9yZXBsYWNlciA9IGZ1bmN0aW9uKHRoaXMgOmFueSwga2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkpOiBhbnkge1xyXG5cdFx0aWYgKHZhbHVlID09PSBudWxsKSByZXR1cm4gdmFsdWU7XHJcblx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikgdmFsdWUgPSB7W2BbRXJyb3JdYF06IFN0cmluZyh2YWx1ZSl9O1xyXG5cdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgU2V0KSB2YWx1ZSA9IHsnW1NldF0nOiBbLi4udmFsdWVdfTtcclxuXHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCkgdmFsdWUgPSB7J1tNYXBdJzogWy4uLnZhbHVlXX07XHJcblx0XHRpZiAoJ29iamVjdCcgPT09IHR5cGVvZiB2YWx1ZSl7XHJcblx0XHRcdGlmIChrZXkpIF9wYXJlbnRzKGtleSwgdmFsdWUpO1xyXG5cdFx0XHRjb25zdCBvdGhlciA9IHJlZnMuZ2V0KHZhbHVlKTtcclxuXHRcdFx0aWYgKG90aGVyKSByZXR1cm4gJ1tDaXJjdWxhcl0nICsgb3RoZXI7XHJcblx0XHRcdGVsc2UgcmVmcy5zZXQodmFsdWUsIHBhdGguam9pbignLicpKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB2YWx1ZTtcclxuXHR9O1xyXG5cdHRyeSB7XHJcblx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgdmFsdWUgPSBfdW5kZWZpbmVkICE9PSB1bmRlZmluZWQgPyBfdW5kZWZpbmVkIDogX3VuZGVmaW5lZCA9IG51bGw7XHJcblx0XHRwYXJlbnRzLnB1c2godmFsdWUpO1xyXG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlLCBfcmVwbGFjZXIsIF9zcGFjZSk7XHJcblx0fVxyXG5cdGZpbmFsbHkge1xyXG5cdFx0X2NsZWFyKCk7XHJcblx0fVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEN1c3RvbSBgSlNPTi5wYXJzZWAgd2l0aCBlcnJvciBjYXRjaCBhbmQgZGVmYXVsdCByZXN1bHQgb24gcGFyc2UgZmFpbHVyZVxyXG4gKiBcclxuICogQHBhcmFtIHZhbHVlXHJcbiAqIEBwYXJhbSBfZGVmYXVsdFxyXG4gKiBAcmV0dXJuc1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IF9qc29uUGFyc2UgPSAodmFsdWU6IHN0cmluZywgX2RlZmF1bHQ/OiBhbnkpOiBhbnkgPT4ge1xyXG5cdHRyeSB7XHJcblx0XHRyZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSk7XHJcblx0fVxyXG5cdGNhdGNoIChlKXtcclxuXHRcdHJldHVybiBfZGVmYXVsdDtcclxuXHR9XHJcbn07XHJcblxyXG4vKipcclxuICogQ2xvbmUgdmFsdWUgdmlhIGpzb24gc3RyaW5naWZ5IGFuZCBwYXJzZVxyXG4gKiBcclxuICogQHBhcmFtIHZhbHVlICBQYXJzZSB2YWx1ZVxyXG4gKiBAcGFyYW0gc3BhY2UgIEluZGVudGF0aW9uIHNwYWNlXHJcbiAqIEBwYXJhbSBfdW5kZWZpbmVkICBEZWZhdWx0IGB1bmRlZmluZWRgIGFyZ3VtZW50IGB2YWx1ZWAgc3Vic3RpdHV0ZSAoZGVmYXVsdCBgbnVsbGApXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgX2pzb25DbG9uZSA9IDxUUmV0dXJuIGV4dGVuZHMgYW55Pih2YWx1ZTogYW55LCBzcGFjZT86IHN0cmluZ3xudW1iZXJ8dW5kZWZpbmVkLCBfdW5kZWZpbmVkOiBhbnkgPSBudWxsKTogVFJldHVybiA9PiB7XHJcblx0bGV0IHZhbDogYW55ID0gX2pzb25TdHJpbmdpZnkodmFsdWUsIHNwYWNlLCBfdW5kZWZpbmVkKTtcclxuXHRpZiAodmFsICE9PSB1bmRlZmluZWQpIHZhbCA9IF9qc29uUGFyc2UodmFsKTtcclxuXHRyZXR1cm4gdmFsIGFzIFRSZXR1cm47XHJcbn07XHJcbiIsImltcG9ydCB7IGJvb2wgfSBmcm9tICcuL19jb21tb24nO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHZhbHVlIGlzIG51bWVyaWNcclxuICogXHJcbiAqIEBwYXJhbSB2YWx1ZSAgUGFyc2UgdmFsdWVcclxuICogQHBhcmFtIGJvb2xlYW5zICBQYXNzIGBib29sZWFuYCB2YWx1ZXMgYXMgbnVtZXJpY1xyXG4gKiBAcGFyYW0gYmxhbmtzICBQYXNzIGVtcHR5IGBzdHJpbmdgIHZhbHVlcyAoYmVjYXVzZSBgIWlzTmFOKCcnKSA9PT0gdHJ1ZWApXHJcbiAqIEByZXR1cm5zIGBib29sZWFuYCBpcyBudW1lcmljXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgX2lzTnVtZXJpYyA9ICh2YWx1ZTogYW55LCBib29sZWFuczogYm9vbCA9IGZhbHNlLCBibGFua3M6IGJvb2wgPSBmYWxzZSk6IGJvb2xlYW4gPT4ge1xyXG5cdGlmICgnbnVtYmVyJyA9PT0gdHlwZW9mIHZhbHVlKSByZXR1cm4gIWlzTmFOKHZhbHVlKTtcclxuXHRpZiAoJ2Jvb2xlYW4nID09PSB0eXBlb2YgdmFsdWUpIHJldHVybiAhIWJvb2xlYW5zO1xyXG5cdGNvbnN0IHYgPSBTdHJpbmcodmFsdWUpLnRyaW0oKTtcclxuXHRpZiAodiA9PT0gJycpIHJldHVybiAhIWJsYW5rcztcclxuXHRyZXR1cm4gLyheWystXT9bMC05XSsoWy5dWzAtOV0rKT8oW2VFXVsrLV0/WzAtOV0rKT8kKXwoXlsrLV0/XFwuWzAtOV0rJCl8KF5bKy1dP1swLTldK1xcLiQpLy50ZXN0KHYpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgdmFsdWUgdG8gbm9ybWFsaXplZCBudW1iZXJcclxuICogXHJcbiAqIC0gQmxhbmsgdHJpbW1lZCBgc3RyaW5nYCB2YWx1ZSBpcyBjb25zaWRlcmVkIGBOYU5gIChpLmUuIFwiXCIpXHJcbiAqIFxyXG4gKiBAcGFyYW0gdmFsdWUgIFBhcnNlIHZhbHVlXHJcbiAqIEBwYXJhbSBfZGVmYXVsdCAgW2RlZmF1bHQ6IGBOYU5gXSBEZWZhdWx0IHJlc3VsdCB3aGVuIHBhcnNlIHJlc3VsdCBpcyBgTmFOYFxyXG4gKiBAcGFyYW0gZml4RmxvYXQgIFtkZWZhdWx0OiBgdHJ1ZWBdIFdoZXRoZXIgdG8gZml4IGZsb2F0IHplcm9zIChpLmUuIGAxLjEvMTAwYCA9IGAwLjAxMTAwMDAwMDAwMDAwMDAwMWAgPT4gYDAuMDExYClcclxuICogQHJldHVybnMgYG51bWJlcmAgcGFyc2VkXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgX3RvTnVtID0gKHZhbHVlOiBhbnksIF9kZWZhdWx0OiBudW1iZXIgPSBOYU4sIGZpeEZsb2F0OiBib29sID0gdHJ1ZSk6IG51bWJlciA9PiB7XHJcblx0bGV0IG51bSA9IHZhbHVlO1xyXG5cdGlmICgnbnVtYmVyJyAhPT0gdHlwZW9mIHZhbHVlKXtcclxuXHRcdGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHZhbHVlKXtcclxuXHRcdFx0bGV0IHAgPSAvXlxccyooW1xcKy1dKVxccyovLCBtYXRjaGVzID0gdmFsdWUubWF0Y2gocCk7IC8vbWF0Y2ggcHJlZml4ICsvLVxyXG5cdFx0XHRpZiAobWF0Y2hlcykgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHAsICcnKTsgLy9yZW1vdmUgcHJlZml4ICsvLVxyXG5cdFx0XHR2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL15cXHMqW1xcKy1dLywgJycpLnRyaW0oKTsgLy9yZW1vdmUgcHJlZml4ICsvLVxyXG5cdFx0XHRpZiAodmFsdWUubWF0Y2goL15cXGR7MSwzfSgsXFxkezN9KSooXFwufChcXC5cXGQrKSk/JC8pKSB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoLywvZywgJycpLnRyaW0oKTsgLy9tYXRjaCBhbmQgcmVtb3ZlIFwiLFwiIHRob3VzYW5kIHNlcGFyYXRvclxyXG5cdFx0XHRpZiAoIXZhbHVlLm1hdGNoKC9eXFxkKihcXC58KFxcLlxcZCspKT8kLykpIHZhbHVlID0gJ3gnOyAvL2ludmFsaWRhdGUgaW52YWxpZCBsZWFkaW5nIGRlY2ltYWwgKGkuZS4gJy4xMCcpXHJcblx0XHRcdGVsc2UgaWYgKG1hdGNoZXMpIHZhbHVlID0gbWF0Y2hlc1sxXSArIHZhbHVlOyAvL3Jlc3RvcmUgcHJlZml4ICsvLVxyXG5cdFx0fVxyXG5cdFx0bnVtID0gIWlzTmFOKG51bSA9IE51bWJlcih2YWx1ZSkpID8gbnVtIDogcGFyc2VGbG9hdChudW0pOyAvL3BhcnNlIG51bWJlclxyXG5cdH1cclxuXHRpZiAoIShudW0gIT09ICcnICYmIG51bSAhPT0gbnVsbCAmJiAhaXNOYU4obnVtID0gTnVtYmVyKG51bSkpKSkgcmV0dXJuIF9kZWZhdWx0OyAvL3JldHVybiBkZWZhdWx0IHdoZW4gdmFsdWUgaXMgbm90IG5vdCBudW1lcmljXHJcblx0bGV0IHZhbCwgbWF0Y2hlcywgcGxhY2VzID0gNTsgLy9maXggZmxvYXQgLSBtYXggNSBkZWNpbWFsIHBsYWNlc1xyXG5cdGlmIChmaXhGbG9hdCAmJiBuZXcgUmVnRXhwKGBcXFxcLlxcXFxkKigweyR7M319XFxcXGQqKWApLnRlc3QodmFsID0gU3RyaW5nKG51bSkpICYmIChtYXRjaGVzID0gdmFsLm1hdGNoKC9cXC4oXFxkKykvKSkpeyBcclxuXHRcdGxldCBmbG9hdHMgPSBtYXRjaGVzWzFdLCBsZW4gPSBmbG9hdHMubGVuZ3RoLCBuID0gLTEsIHggPSAtMTtcclxuXHRcdGZvciAobGV0IGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSl7XHJcblx0XHRcdGlmICghTnVtYmVyKGZsb2F0c1tpXSkpe1xyXG5cdFx0XHRcdGlmICh4IDwgMCkgeCA9IGk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZiAoeCA+IC0xKXtcclxuXHRcdFx0XHRuID0gaTtcclxuXHRcdFx0XHRpZiAoeCAtIG4gPj0gcGxhY2VzKSBicmVhaztcclxuXHRcdFx0XHRlbHNlIHggPSBuID0gLTE7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGlmIChuID4gLTEgJiYgeCA+IC0xICYmICh4IC0gbiA+PSBwbGFjZXMpKSBudW0gPSArdmFsLnN1YnN0cmluZygwLCB2YWwubGVuZ3RoIC0gbGVuICsgeCArIDEpO1xyXG5cdH1cclxuXHRyZXR1cm4gbnVtO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFBhcnNlIHZhbHVlIHRvIG51bWJlciAoc2hvcnRoYW5kKVxyXG4gKiBcclxuICogQHBhcmFtIHZhbHVlICBQYXJzZSB2YWx1ZVxyXG4gKiBAcGFyYW0gX2RlZmF1bHQgIFtkZWZhdWx0OiBgTmFOYF0gRGVmYXVsdCByZXN1bHQgd2hlbiBwYXJzZSByZXN1bHQgaXMgYE5hTmBcclxuICogQHJldHVybnMgYG51bWJlcmAgcGFyc2VkXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgX251bSA9ICh2YWx1ZTogYW55LCBfZGVmYXVsdDogbnVtYmVyID0gTmFOKTogbnVtYmVyID0+IF90b051bSh2YWx1ZSwgX2RlZmF1bHQpO1xyXG5cclxuLyoqXHJcbiAqIFBhcnNlIHZhbHVlIHRvIGludGVnZXJcclxuICogXHJcbiAqIEBwYXJhbSB2YWx1ZSAgUGFyc2UgdmFsdWVcclxuICogQHBhcmFtIF9kZWZhdWx0ICBbZGVmYXVsdDogYE5hTmBdIERlZmF1bHQgcmVzdWx0IHdoZW4gcGFyc2UgcmVzdWx0IGlzIGBOYU5gXHJcbiAqIEByZXR1cm5zIGBudW1iZXJgIGludGVnZXJcclxuICovXHJcbmV4cG9ydCBjb25zdCBfaW50ID0gKHZhbHVlOiBhbnksIF9kZWZhdWx0OiBudW1iZXIgPSBOYU4pOiBudW1iZXIgPT4gcGFyc2VJbnQoU3RyaW5nKF90b051bSh2YWx1ZSwgX2RlZmF1bHQpKSk7XHJcblxyXG4vKipcclxuICogUm91bmQgbnVtYmVyIHRvIGRlY2ltYWwgcGxhY2VzXHJcbiAqIFxyXG4gKiBAcGFyYW0gdmFsdWUgIFBhcnNlIHZhbHVlXHJcbiAqIEBwYXJhbSBwbGFjZXMgIFtkZWZhdWx0OiBgMmBdIERlY2ltYWwgcGxhY2VzXHJcbiAqIEByZXR1cm5zIGBudW1iZXJgIHJvdW5kZWRcclxuICovXHJcbmV4cG9ydCBjb25zdCBfcm91bmQgPSAodmFsdWU6IG51bWJlciwgcGxhY2VzOiBudW1iZXIgPSAyKTogbnVtYmVyID0+IHtcclxuXHRpZiAoaXNOYU4odmFsdWUpKSByZXR1cm4gTmFOO1xyXG5cdGxldCBwID0gMTAgKiogTWF0aC5hYnMoX2ludChwbGFjZXMsIDIpKTtcclxuXHRyZXR1cm4gTWF0aC5yb3VuZCgodmFsdWUgKyBOdW1iZXIuRVBTSUxPTikgKiBwKSAvIHA7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydCBudW1lcmljIHZhbHVlIHRvIGNvbW1hIHRob3VzYW5kIGRlbGltaXRlZCBzdHJpbmcgKGkuZS4gYDEwMDAuNDU2N2AgPT4gYCcxLDAwMC40NSdgKVxyXG4gKiBcclxuICogQHBhcmFtIHZhbHVlICBQYXJzZSB2YWx1ZVxyXG4gKiBAcGFyYW0gcGxhY2VzICBbZGVmYXVsdDogYDJgXSBSb3VuZCBkZWNpbWFsIHBsYWNlc1xyXG4gKiBAcGFyYW0gemVyb3MgIEVuYWJsZSB0cmFpbGluZyBgJzAnYCBkZWNpbWFsIHBsYWNlcyAoaS5lLiBgMTAwMGAgPT4gYCcxLDAwMC4wMCdgKVxyXG4gKiBAcmV0dXJucyBgc3RyaW5nYCBDb21tYSB0aG91c2FuZCBkZWxpbWl0ZWQgbnVtYmVyIChyZXR1cm5zIGBcIlwiYCBpZiBwYXJzZWQgYHZhbHVlYCBpcyBgTmFOYClcclxuICovXHJcbmV4cG9ydCBjb25zdCBfY29tbWFzID0gKHZhbHVlOiBhbnksIHBsYWNlczogbnVtYmVyID0gMiwgemVyb3M6IGJvb2wgPSBmYWxzZSk6IHN0cmluZyA9PiB7XHJcblx0Y29uc3QgbnVtID0gX3JvdW5kKF9udW0odmFsdWUpLCBwbGFjZXMgPSBfaW50KHBsYWNlcywgMikpO1xyXG5cdGlmIChpc05hTihudW0pKXtcclxuXHRcdGNvbnNvbGUud2FybignW1dBUk5JTkc6IGBfY29tbWFzYF0gTmFOIHZhbHVlOicsIHZhbHVlKTtcclxuXHRcdHJldHVybiAnJztcclxuXHR9XHJcblx0bGV0IHZhbCA9IFN0cmluZyhudW0pLnJlcGxhY2UoL1xcQig/PShcXGR7M30pKyg/IVxcZCkpL2csICcsJyk7XHJcblx0aWYgKHBsYWNlcyAmJiB6ZXJvcyl7XHJcblx0XHRpZiAodmFsLmluZGV4T2YoJy4nKSA9PT0gLTEpIHZhbCArPSAnLicucGFkRW5kKHBsYWNlcyArIDEsICcwJyk7XHJcblx0XHRlbHNlIHZhbCA9IHZhbC5zcGxpdCgnLicpLnJlZHVjZTxzdHJpbmdbXT4oKHByZXYsIHYsIGkpID0+IHtcclxuXHRcdFx0cHJldi5wdXNoKGkgPT09IDEgJiYgdi5sZW5ndGggPCBwbGFjZXMgPyB2LnBhZEVuZChwbGFjZXMsICcwJykgOiB2KTtcclxuXHRcdFx0cmV0dXJuIHByZXY7XHJcblx0XHR9LCBbXSkuam9pbignLicpO1xyXG5cdH1cclxuXHRyZXR1cm4gdmFsO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlIHJhbmRvbSBgaW50ZWdlcmAgbnVtYmVyLlxyXG4gKiBcclxuICogQHBhcmFtIG1pbiAgTWluIGBpbnRlZ2VyYFxyXG4gKiBAcGFyYW0gbWF4ICBNYXggYGludGVnZXJgXHJcbiAqIEByZXR1cm5zICBgbnVtYmVyYCBSYW5kb20gYGludGVnZXJgXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgX3JhbmQgPSAobWluOiBudW1iZXIsIG1heDogbnVtYmVyKTogbnVtYmVyID0+IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSkgKyBtaW47IiwiaW1wb3J0IHsgYm9vbCB9IGZyb20gJy4vX2NvbW1vbic7XHJcblxyXG4vKipcclxuICogRmxhdHRlbiBhcnJheSByZWN1cnNpdmVseVxyXG4gKiBcclxuICogQHBhcmFtIHZhbHVlc1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IF9mbGF0dGVuID0gKHZhbHVlczogYW55W10pOiBhbnlbXSA9PiB2YWx1ZXMuZmxhdChJbmZpbml0eSk7XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdmFsdWUgaGFzIHByb3BlcnR5XHJcbiAqIFxyXG4gKiBAcGFyYW0gdmFsdWUgIFNlYXJjaCBgb2JqZWN0YCB2YWx1ZVxyXG4gKiBAcGFyYW0gcHJvcCAgRmluZCBwcm9wZXJ0eVxyXG4gKiBAcGFyYW0gb3duICBbZGVmYXVsdDogYGZhbHNlYF0gQXMgb3duIHByb3BlcnR5XHJcbiAqIFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IF9oYXNQcm9wID0gKHZhbHVlOiBhbnksIHByb3A6IGFueSwgb3duOiBib29sID0gZmFsc2UpOiBib29sZWFuID0+IHtcclxuXHRpZiAoISgnb2JqZWN0JyA9PT0gdHlwZW9mIHZhbHVlICYmIHZhbHVlKSkgcmV0dXJuIGZhbHNlO1xyXG5cdHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHByb3ApIHx8IChvd24gPyBmYWxzZSA6IHByb3AgaW4gdmFsdWUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIG9iamVjdCBoYXMgcHJvcGVydGllc1xyXG4gKiBcclxuICogQHBhcmFtIHZhbHVlICBTZWFyY2ggYG9iamVjdGAgdmFsdWVcclxuICogQHBhcmFtIHByb3BzICBTcHJlYWQgZmluZCBwcm9wZXJ0aWVzXHJcbiAqIFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IF9oYXNQcm9wcyA9ICh2YWx1ZTogYW55LCAuLi5wcm9wczogYW55KTogYm9vbGVhbiA9PiAhcHJvcHMubGVuZ3RoID8gZmFsc2UgOiAhcHJvcHMuZmlsdGVyKChrOiBhbnkpID0+ICFfaGFzUHJvcCh2YWx1ZSwgaykpLmxlbmd0aDtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBvYmplY3QgaGFzIGFueSBvZiB0aGUgcHJvcGVydGllc1xyXG4gKiBcclxuICogQHBhcmFtIHZhbHVlICBTZWFyY2ggYG9iamVjdGAgdmFsdWVcclxuICogQHBhcmFtIHByb3BzICBTcHJlYWQgZmluZCBwcm9wZXJ0aWVzXHJcbiAqIFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IF9oYXNBbnlQcm9wcyA9ICh2YWx1ZTogYW55LCAuLi5wcm9wczogYW55KTogYm9vbGVhbiA9PiAhcHJvcHMubGVuZ3RoID8gZmFsc2UgOiAhIXByb3BzLmZpbHRlcigoazogYW55KSA9PiBfaGFzUHJvcCh2YWx1ZSwgaykpLmxlbmd0aDsiLCJpbXBvcnQgeyBfc3RyIH0gZnJvbSAnLi9fc3RyaW5nJztcclxuXHJcbi8qKlxyXG4gKiBQcm9taXNlIHJlc3VsdCBpbnRlcmZhY2VcclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSVByb21pc2VSZXN1bHQ8VFJlc3VsdD4ge1xyXG5cdHN0YXR1czogJ3Jlc29sdmVkJ3wncmVqZWN0ZWQnO1xyXG5cdGluZGV4OiBudW1iZXI7XHJcblx0dmFsdWU/OiBUUmVzdWx0O1xyXG5cdHJlYXNvbj86IGFueTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFBhcmFsbGVsIHJlc29sdmUgYGFycmF5YCB2YWx1ZXMgY2FsbGJhY2sgcHJvbWlzZXNcclxuICogLSBpLmUuIGF3YWl0IF9hc3luY0FsbDxudW1iZXIsIG51bWJlcj4oWzEsIDJdLCBhc3luYyAobnVtKSA9PiBudW0gKiAyKSAtLT4gW3tzdGF0dXM6ICdyZXNvbHZlZCcsIGluZGV4OiAwLCB2YWx1ZTogMn0sIHtzdGF0dXM6ICdyZXNvbHZlZCcsIGluZGV4OiAxLCB2YWx1ZTogNH1dXHJcbiAqIFxyXG4gKiBAcGFyYW0gYXJyYXkgIEVudHJpZXNcclxuICogQHBhcmFtIGNhbGxiYWNrICBFbnRyeSBjYWxsYmFja1xyXG4gKiBAcmV0dXJucyBgUHJvbWlzZTxJUHJvbWlzZVJlc3VsdDxUUmVzdWx0PltdPmBcclxuICovXHJcbmV4cG9ydCBjb25zdCBfYXN5bmNBbGwgPSBhc3luYzxUIGV4dGVuZHMgYW55LCBUUmVzdWx0IGV4dGVuZHMgYW55PihhcnJheTogVFtdLCBjYWxsYmFjaz86ICh2YWx1ZTogVCwgaW5kZXg6IG51bWJlciwgYXJyYXk6IFRbXSkgPT4gUHJvbWlzZTxUUmVzdWx0Pik6IFByb21pc2U8SVByb21pc2VSZXN1bHQ8VFJlc3VsdD5bXT4gPT4ge1xyXG5cdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG5cdFx0Y29uc3QgX2J1ZmZlcjogSVByb21pc2VSZXN1bHQ8VFJlc3VsdD5bXSA9IFtdLCBfbGVuID0gYXJyYXkubGVuZ3RoO1xyXG5cdFx0Y29uc3QgX3Jlc29sdmUgPSAoKSA9PiByZXNvbHZlKF9idWZmZXIpO1xyXG5cdFx0aWYgKCFfbGVuKSByZXR1cm4gX3Jlc29sdmUoKTtcclxuXHRcdGxldCBjb3VudCA9IDA7XHJcblx0XHRhcnJheS5mb3JFYWNoKCh2LCBpLCBhKSA9PiB7XHJcblx0XHRcdChhc3luYygpPT5Qcm9taXNlLnJlc29sdmUoY2FsbGJhY2sgPyBjYWxsYmFjayh2LCBpLCBhKSA6IHYpIGFzIFByb21pc2U8VFJlc3VsdD4pKClcclxuXHRcdFx0LnRoZW4odmFsdWUgPT4gX2J1ZmZlci5wdXNoKHtzdGF0dXM6ICdyZXNvbHZlZCcsIGluZGV4OiBpLCB2YWx1ZX0pKVxyXG5cdFx0XHQuY2F0Y2gocmVhc29uID0+IF9idWZmZXIucHVzaCh7c3RhdHVzOiAncmVqZWN0ZWQnLCBpbmRleDogaSwgcmVhc29ufSkpXHJcblx0XHRcdC5maW5hbGx5KCgpID0+ICsrY291bnQgPT09IF9sZW4gPyBfcmVzb2x2ZSgpIDogdW5kZWZpbmVkKTtcclxuXHRcdH0pO1xyXG5cdH0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCBhc3luYyBpdGVyYWJsZSB2YWx1ZXMgKGkuZS4gYGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgX2FzeW5jVmFsdWVzKGFycmF5KSl7Li4ufWApXHJcbiAqIFxyXG4gKiBAcGFyYW0gYXJyYXkgIFZhbHVlc1xyXG4gKiBAcmV0dXJucyBBc3luYyBpdGVyYWJsZSBvYmplY3RcclxuICovXHJcbmV4cG9ydCBjb25zdCBfYXN5bmNWYWx1ZXMgPSA8VCBleHRlbmRzIGFueT4oYXJyYXk6IFRbXSk6IHtcclxuXHR2YWx1ZXM6ICgpID0+IFRbXSxcclxuXHRzaXplOiAoKSA9PiBudW1iZXI7XHJcblx0ZWFjaDogKGNhbGxiYWNrOiAodmFsdWU6IFQsIGluZGV4OiBudW1iZXIsIGxlbmd0aDogbnVtYmVyLCBfYnJlYWs6ICgpPT52b2lkKT0+UHJvbWlzZTxhbnk+KSA9PiBQcm9taXNlPHZvaWQ+O1xyXG5cdFtTeW1ib2wuYXN5bmNJdGVyYXRvcl06ICgpID0+IHtcclxuXHRcdG5leHQ6ICgpID0+IFByb21pc2U8e2RvbmU6IGJvb2xlYW47IHZhbHVlOiBUfT47XHJcblx0fVxyXG59ID0+ICh7XHJcblx0dmFsdWVzOiAoKSA9PiBhcnJheSxcclxuXHRzaXplOiAoKSA9PiBhcnJheS5sZW5ndGgsXHJcblx0YXN5bmMgZWFjaChjYWxsYmFjazogKHZhbHVlOiBULCBpbmRleDogbnVtYmVyLCBsZW5ndGg6IG51bWJlciwgX2JyZWFrOiAoKT0+dm9pZCk9PlByb21pc2U8YW55Pik6IFByb21pc2U8dm9pZD4ge1xyXG5cdFx0bGV0IHNlbGYgPSB0aGlzLCBjYW5jZWwgPSBmYWxzZSwgaW5kZXggPSAtMSwgX2JyZWFrID0gKCkgPT4ge1xyXG5cdFx0XHRjYW5jZWwgPSB0cnVlO1xyXG5cdFx0fTtcclxuXHRcdGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2Ygc2VsZil7XHJcblx0XHRcdGluZGV4ICsrO1xyXG5cdFx0XHRpZiAoY2FuY2VsKSBicmVhaztcclxuXHRcdFx0YXdhaXQgY2FsbGJhY2sodmFsdWUsIGluZGV4LCBzZWxmLnNpemUoKSwgX2JyZWFrKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKXtcclxuXHRcdGxldCBpbmRleCA9IDA7XHJcblx0XHRjb25zdCB0aGF0ID0gdGhpcztcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdGFzeW5jIG5leHQoKTogUHJvbWlzZTx7ZG9uZTogYm9vbGVhbjsgdmFsdWU6IFR9PiB7XHJcblx0XHRcdFx0bGV0IHZhbHVlOiBUID0gdW5kZWZpbmVkIGFzIFQsIGxlbmd0aCA9IHRoYXQuc2l6ZSgpO1xyXG5cdFx0XHRcdGlmIChpbmRleCA+PSBsZW5ndGgpIHJldHVybiB7ZG9uZTogdHJ1ZSwgdmFsdWV9O1xyXG5cdFx0XHRcdHZhbHVlID0gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKGFycmF5W2luZGV4XSk7XHJcblx0XHRcdFx0aW5kZXggKys7XHJcblx0XHRcdFx0cmV0dXJuIHtkb25lOiBmYWxzZSwgdmFsdWV9O1xyXG5cdFx0XHR9LFxyXG5cdFx0fTtcclxuXHR9LFxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBEZWxheSBwcm9taXNlXHJcbiAqIFxyXG4gKiBAcGFyYW0gdGltZW91dCAgRGVsYXkgbWlsbGlzZWNvbmRzXHJcbiAqIEByZXR1cm5zIGBQcm9taXNlPG51bWJlcj5gIHRpbWVvdXRcclxuICovXHJcbmV4cG9ydCBjb25zdCBfc2xlZXAgPSBhc3luYyAodGltZW91dDogbnVtYmVyKTogUHJvbWlzZTxudW1iZXI+ID0+IHtcclxuXHR0aW1lb3V0ID0gIWlzTmFOKHRpbWVvdXQpICYmIHRpbWVvdXQgPj0gMCA/IHRpbWVvdXQgOiAwXHJcblx0cmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKHRpbWVvdXQpLCB0aW1lb3V0KSk7XHJcbn07IiwiLyoqXHJcbiAqIFF1ZXVlIG9iamVjdCBpbnRlcmZhY2VcclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSVF1ZXVlPFQ+IHtcclxuXHRjb3VudDogbnVtYmVyO1xyXG5cdGxlbmd0aDogbnVtYmVyO1xyXG5cdGlzRW1wdHk6IGJvb2xlYW47XHJcblx0ZW5xdWV1ZSh2YWx1ZTogVCk6IHZvaWQ7XHJcblx0ZGVxdWV1ZSgpOiBUfHVuZGVmaW5lZDtcclxuXHRwZWVrKCk6IFR8dW5kZWZpbmVkO1xyXG5cdHZhbHVlcygpOiBUW107XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGUgcXVldWUgb2JqZWN0XHJcbiAqIFxyXG4gKiBAcmV0dXJucyBgSVF1ZXVlYFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IF9xdWV1ZSA9IDxUIGV4dGVuZHMgYW55PigpOiBJUXVldWU8VD4gPT4ge1xyXG5cdGNvbnN0IGl0ZW1zOiB7W2tleTogbnVtYmVyXTogVH0gPSB7fTtcclxuXHRsZXQgaGVhZDogbnVtYmVyID0gMDtcclxuXHRsZXQgdGFpbDogbnVtYmVyID0gMDtcclxuXHRyZXR1cm4ge1xyXG5cdFx0Z2V0IGNvdW50KCk6IG51bWJlciB7XHJcblx0XHRcdHJldHVybiB0YWlsO1xyXG5cdFx0fSxcclxuXHRcdGdldCBsZW5ndGgoKTogbnVtYmVyIHtcclxuXHRcdFx0cmV0dXJuIHRhaWwgLSBoZWFkO1xyXG5cdFx0fSxcclxuXHRcdGdldCBpc0VtcHR5KCk6IGJvb2xlYW4ge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5sZW5ndGggPT09IDA7XHJcblx0XHR9LFxyXG5cdFx0ZW5xdWV1ZSh2YWx1ZTogVCk6IHZvaWQge1xyXG5cdFx0XHRpdGVtc1t0YWlsXSA9IHZhbHVlO1xyXG5cdFx0XHR0YWlsICsrO1xyXG5cdFx0fSxcclxuXHRcdGRlcXVldWUoKTogVHx1bmRlZmluZWQge1xyXG5cdFx0XHRjb25zdCBpdGVtID0gaXRlbXNbaGVhZF07XHJcblx0XHRcdGRlbGV0ZSBpdGVtc1toZWFkXTtcclxuXHRcdFx0aGVhZCArKztcclxuXHRcdFx0cmV0dXJuIGl0ZW07XHJcblx0XHR9LFxyXG5cdFx0cGVlaygpOiBUfHVuZGVmaW5lZCB7XHJcblx0XHRcdHJldHVybiBpdGVtc1toZWFkXTtcclxuXHRcdH0sXHJcblx0XHR2YWx1ZXMoKTogVFtdIHtcclxuXHRcdFx0cmV0dXJuIE9iamVjdC52YWx1ZXMoaXRlbXMpO1xyXG5cdFx0fSxcclxuXHR9O1xyXG59OyIsIi8qKlxyXG4gKiBTb3J0IGRpcmVjdGlvbiB0eXBlXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBTb3J0RGlyZWN0aW9uID0gMXwtMXwnYXNjJ3wnZGVzYyd8J2FzY2VuZGluZyd8J2Rlc2NlbmRpbmcnO1xyXG5cclxuLyoqXHJcbiAqIFNvcnQgb3JkZXIgdHlwZVxyXG4gKi9cclxuZXhwb3J0IHR5cGUgU29ydE9yZGVyID0gU29ydERpcmVjdGlvbnx7W2tleTogc3RyaW5nXTogU29ydERpcmVjdGlvbn07XHJcblxyXG4vKipcclxuICogU29ydCBhcnJheSB2YWx1ZXNcclxuICogXHJcbiAqIEBwYXJhbSBhcnJheVxyXG4gKiBAcGFyYW0gc29ydFxyXG4gKiBAcmV0dXJucyBTb3J0ZWQgYGFycmF5YFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IF9zb3J0VmFsdWVzID0gPFQgZXh0ZW5kcyBhbnk+KGFycmF5OiBUW10sIHNvcnQ/OiBTb3J0T3JkZXIpOiBUW10gPT4ge1xyXG5cdGNvbnN0IF9jb21wYXJlID0gKGE6IGFueSwgYjogYW55KTogbnVtYmVyID0+IHtcclxuXHRcdGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIGEgJiYgJ3N0cmluZycgPT09IHR5cGVvZiBiICYmICdmdW5jdGlvbicgPT09IHR5cGVvZiBhPy5sb2NhbGVDb21wYXJlKSByZXR1cm4gYS5sb2NhbGVDb21wYXJlKGIpO1xyXG5cdFx0cmV0dXJuIGEgPiBiID8gMSA6IChhIDwgYiA/IC0xIDogMCk7XHJcblx0fTtcclxuXHRjb25zdCBfZGlyZWN0aW9uID0gKHZhbD86IFNvcnREaXJlY3Rpb24pOiBudW1iZXIgPT4ge1xyXG5cdFx0aWYgKCdudW1iZXInID09PSB0eXBlb2YgdmFsICYmIFsxLCAtMV0uaW5jbHVkZXModmFsKSkgcmV0dXJuIHZhbDtcclxuXHRcdGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHZhbCl7XHJcblx0XHRcdGlmICh2YWwuc3RhcnRzV2l0aCgnYXNjJykpIHJldHVybiAxO1xyXG5cdFx0XHRpZiAodmFsLnN0YXJ0c1dpdGgoJ2Rlc2MnKSkgcmV0dXJuIC0xO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIDE7XHJcblx0fTtcclxuXHRjb25zdCBfbWV0aG9kID0gKCk6ICgoYTogYW55LCBiOiBhbnkpPT5udW1iZXIpID0+IHtcclxuXHRcdGlmIChPYmplY3Qoc29ydCkgPT09IHNvcnQpe1xyXG5cdFx0XHRjb25zdCBfZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHNvcnQgYXMge1trZXk6IHN0cmluZ106IFNvcnREaXJlY3Rpb259KTtcclxuXHRcdFx0aWYgKF9lbnRyaWVzLmxlbmd0aCkgcmV0dXJuIChhLCBiKSA9PiB7XHJcblx0XHRcdFx0bGV0IGksIHJlc3VsdDtcclxuXHRcdFx0XHRmb3IgKHJlc3VsdCA9IDAsIGkgPSAwOyByZXN1bHQgPT09IDAgfHwgaSA8IF9lbnRyaWVzLmxlbmd0aDsgaSArKyl7XHJcblx0XHRcdFx0XHRjb25zdCBba2V5LCB2YWxdID0gX2VudHJpZXNbaV07XHJcblx0XHRcdFx0XHRyZXN1bHQgPSBfY29tcGFyZShhPy5ba2V5XSwgYj8uW2tleV0pICogX2RpcmVjdGlvbih2YWwpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIChhLCBiKSA9PiBfY29tcGFyZShhLCBiKSAqIF9kaXJlY3Rpb24oc29ydCBhcyBTb3J0RGlyZWN0aW9uKTtcclxuXHR9O1xyXG5cdHJldHVybiBhcnJheS5zb3J0KF9tZXRob2QoKSk7XHJcbn07IiwiaW1wb3J0IHsgYm9vbCB9IGZyb20gJy4vX2NvbW1vbic7XHJcbmltcG9ydCB7IF9qc29uU3RyaW5naWZ5IH0gZnJvbSAnLi9fanNvbic7XHJcblxyXG4vKipcclxuICogR2V0IHVuaXF1ZSBzdHJpbmcgb2YgcmFuZG9tIGNoYXJhY3RlcnMgKGluIGxvd2VyY2FzZSlcclxuICogXHJcbiAqIEBwYXJhbSBsZW5ndGggIChtYXggNjQpXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gX3V1aWQobGVuZ3RoPzogbnVtYmVyKTogc3RyaW5ne1xyXG5cdGNvbnN0IF91aWQgPSAoKSA9PiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMikgKyAobmV3IERhdGUoKSkuZ2V0VGltZSgpLnRvU3RyaW5nKDM2KTtcclxuXHRpZiAoIShsZW5ndGggIT09IHVuZGVmaW5lZCAmJiBOdW1iZXIuaXNJbnRlZ2VyKGxlbmd0aCkgJiYgbGVuZ3RoID4gMCAmJiBsZW5ndGggPD0gNjQpKSByZXR1cm4gX3VpZCgpO1xyXG5cdGxldCBidWZmZXIgPSAnJztcclxuXHR3aGlsZSAoYnVmZmVyLmxlbmd0aCA8IGxlbmd0aCkgYnVmZmVyICs9IF91aWQoKTtcclxuXHRyZXR1cm4gYnVmZmVyLnN1YnN0cmluZygwLCBsZW5ndGgpO1xyXG59XHJcblxyXG4vKipcclxuICogU2FmZWx5IGBzdHJpbmdgIGNhc3QgdmFsdWVcclxuICogLSBSZXR1cm5zIElTTyBmb3JtYXQgdGltZXN0YW1wIGZvciB2YWxpZCBEYXRlIHZhbHVlXHJcbiAqIFxyXG4gKiBAcGFyYW0gdmFsdWUgIENhc3QgdmFsdWVcclxuICogQHBhcmFtIF9kZWZhdWx0ICBbZGVmYXVsdDogYCcnYF0gRGVmYXVsdCByZXN1bHQgb24gZmFpbHVyZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IF9zdHJpbmcgPSAodmFsdWU6IGFueSwgX2RlZmF1bHQ6IHN0cmluZyA9ICcnKTogc3RyaW5nID0+IHtcclxuXHRsZXQgdmFsOiBzdHJpbmcgPSAnJztcclxuXHR0cnkge1xyXG5cdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSAmJiAhaXNOYU4odmFsdWUuZ2V0VGltZSgpKSkgdmFsID0gdmFsdWUudG9JU09TdHJpbmcoKTtcclxuXHRcdGVsc2UgdmFsID0gU3RyaW5nKHZhbHVlKTtcclxuXHR9XHJcblx0Y2F0Y2ggKGUpe1xyXG5cdFx0dmFsID0gX2RlZmF1bHQ7XHJcblx0fVxyXG5cdHJldHVybiB2YWw7XHJcbn07XHJcblxyXG4vKipcclxuICogU2FmZWx5IGBzdHJpbmdgIGNhc3QgdmFsdWUgaWYgcG9zc2libGUuXHJcbiAqIFxyXG4gKiBAcGFyYW0gdmFsdWVcclxuICogQHJldHVybnMgYGZhbHNlfHN0cmluZ2AgQ2FzdCByZXN1bHQgb3IgYGZhbHNlYCBvbiBmYWlsdXJlXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgX3N0cmluZ2FibGUgPSAodmFsdWU6IGFueSk6IGZhbHNlfHN0cmluZyA9PiB7XHJcblx0Y29uc3QgZmFpbGVkID0gYCEke0RhdGUubm93KCl9IWAsIHZhbCA9IF9zdHJpbmcodmFsdWUsIGZhaWxlZCksIHBhdHRlcm4gPSAvXFxbb2JqZWN0IFxcdytcXF0vO1xyXG5cdHJldHVybiAhKHZhbCA9PT0gZmFpbGVkIHx8IHBhdHRlcm4udGVzdCh2YWwpKSA/IHZhbCA6IGZhbHNlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgdmFsdWUgdG8gYHN0cmluZ2AgZXF1aXZhbGVudFxyXG4gKiBcclxuICogLSBSZXR1cm5zICcnIGZvciBgbnVsbGAgYW5kIGB1bmRlZmluZWRgIHZhbHVlXHJcbiAqIC0gV2hlbiBgc3RyaW5naWZ5YCBpcyBgZmFsc2VgLCByZXR1cm5zICcnIGZvciBgYXJyYXlgIG9yIGBvYmplY3RgIHZhbHVlIHRoYXQgZG9lcyBub3QgaW1wbGVtZW50IGB0b1N0cmluZygpYCBtZXRob2RcclxuICogXHJcbiAqIEBwYXJhbSB2YWx1ZVxyXG4gKiBAcGFyYW0gdHJpbSAgVHJpbSByZXN1bHRcclxuICogQHBhcmFtIHN0cmluZ2lmeSAgU3RyaW5naWZ5IGBhcnJheWAgb3IgYG9iamVjdGAgdmFsdWUgdGhhdCBkb2VzIG5vdCBpbXBsZW1lbnQgYHRvU3RyaW5nKClgIG1ldGhvZFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IF9zdHIgPSAodmFsdWU6IGFueSwgdHJpbTogYm9vbGVhbiA9IGZhbHNlLCBzdHJpbmdpZnk6IGJvb2xlYW4gPSBmYWxzZSk6IHN0cmluZyA9PiB7XHJcblx0aWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgdmFsdWUpe1xyXG5cdFx0aWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiAnJztcclxuXHRcdGVsc2UgaWYgKCdvYmplY3QnID09PSB0eXBlb2YgdmFsdWUpe1xyXG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHJldHVybiBzdHJpbmdpZnkgPyBfanNvblN0cmluZ2lmeSh2YWx1ZSkgOiAnJztcclxuXHRcdFx0Y29uc3QgdG1wID0gX3N0cmluZ2FibGUodmFsdWUpO1xyXG5cdFx0XHRpZiAodG1wID09PSBmYWxzZSkgcmV0dXJuIHN0cmluZ2lmeSA/IF9qc29uU3RyaW5naWZ5KHZhbHVlKSA6ICcnO1xyXG5cdFx0XHRlbHNlIHZhbHVlID0gdG1wO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSB2YWx1ZSA9IF9zdHJpbmcodmFsdWUpO1xyXG5cdH1cclxuXHRyZXR1cm4gdHJpbSA/IHZhbHVlLnRyaW0oKSA6IHZhbHVlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE5vcm1hbGl6ZSBzdHJpbmcgYnkgcmVtb3ZpbmcgYWNjZW50cyAoaS5lLiBcIkFtw6lsaWVcIiA9PiBcIkFtZWxpZVwiKVxyXG4gKiBcclxuICogQHBhcmFtIHZhbHVlXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgX3N0ck5vcm0gPSAodmFsdWU6IGFueSk6IHN0cmluZyA9PiBfc3RyKHZhbHVlKS5ub3JtYWxpemUoJ05GRCcpLnJlcGxhY2UoL1tcXHUwMzAwLVxcdTAzNmZdL2csICcnKTtcclxuXHJcbi8qKlxyXG4gKiBFc2NhcGUgcmVnZXggb3BlcmF0b3JzIGZyb20gc3RyaW5nXHJcbiAqIC0gaS5lLiBgJ1xcXFxzXFxuXFxyXFx0XFx2XFx4MDB+XyFAIyQlXiYqKClbXVxcXFwvLC4/XCJcXCc6O3t9fDw+PSstJ2AgPT4gYCdcXFxcc1xcblxcclxcdFxcdlxceDAwXFxzfl8hQCNcXFxcJCVcXFxcXiZcXFxcKlxcXFwoXFxcXClcXFxcW1xcXFxdXFxcXFxcXFwvLFxcXFwuXFxcXD9cIlxcJzo7XFxcXHtcXFxcfVxcXFx8PD49XFxcXCstJ2BcclxuICogXHJcbiAqIEBwYXJhbSB2YWx1ZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IF9yZWdFc2NhcGUgPSAodmFsdWU6IGFueSk6IHN0cmluZyA9PiBfc3RyKHZhbHVlKS5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpO1xyXG5cclxuLyoqXHJcbiAqIEVzY2FwZSBzdHJpbmcgc3BlY2lhbCBjaGFyYWN0ZXJzXHJcbiAqIC0gaS5lLiBgJ1xcclxcblxcdFxcZlxcdlxceDAwLVxcdTAwZjMtXFx1MTIzNC1cXHhiNC1cXHUwMDBiLS9cXFxcJ2AgPT4gYCdcXFxcclxcXFxuXFxcXHRcXFxcZlxcXFx2XFxcXHgwMC3Dsy3hiLQtwrQtXFxcXHYtL1xcXFxcXFxcJ2BcclxuICogXHJcbiAqIEBwYXJhbSB2YWx1ZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IF9zdHJFc2NhcGUgPSAodmFsdWU6IGFueSk6IHN0cmluZyA9PiBKU09OLnN0cmluZ2lmeShfc3RyKHZhbHVlKSlcclxuLnJlcGxhY2UoL1xcXFx1KFtcXGRcXHddezR9KS9nLCAobSwgcykgPT4ge1xyXG5cdGNvbnN0IGggPSBwYXJzZUludChzLCAxNik7XHJcblx0cmV0dXJuIGggPiAyNTUgPyBtIDogJ1xcXFwnICsgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZy5mcm9tQ2hhckNvZGUoaCkpLnJlcGxhY2UoJyUnLCAneCcpLnJlcGxhY2UoJ3gwQicsICd2Jyk7XHJcbn0pXHJcbi5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxyXG4ucmVwbGFjZSgvXFxcXFwiL2csICdcIicpO1xyXG5cclxuLyoqXHJcbiAqIFJlZ2V4IHN0cmluZyB0cmltIGNoYXJhY3RlcnNcclxuICogXHJcbiAqIEBwYXJhbSB2YWx1ZSAgVHJpbSB2YWx1ZVxyXG4gKiBAcGFyYW0gY2hhcnMgIFN0cmlwIGNoYXJhY3RlcnMgW2RlZmF1bHQ6IGAnIFxcblxcclxcdFxcZlxcdlxceDAwJ2BdIC0gdXNlIGAne2RlZmF1bHR9J2AgdG8gaW5jbHVkZSBkZWZhdWx0cyAoaS5lIGAnLXtkZWZhdWx0c30nYCA9PSBgJy0gXFxuXFxyXFx0XFxmXFx2XFx4MDAnYClcclxuICogQHBhcmFtIHJsICBUcmltIG1vZGUgKGAnJ2AgPT4gKGRlZmF1bHQpIHRyaW0gcmlnaHQgJiBsZWZ0LCBgJ3InfCdyaWdodCdgID0+IHRyaW0gcmlnaHQsIGAnbCd8J2xlZnQnYCA9PiB0cmltIGxlZnQpXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgX3RyaW0gPSAodmFsdWU6IGFueSwgY2hhcnM6IHN0cmluZyA9ICcgXFxyXFxuXFx0XFxmXFx2XFx4MDAnLCBybDogJyd8J3InfCdsJ3wncmlnaHQnfCdsZWZ0JyA9ICcnKTogc3RyaW5nID0+IHtcclxuXHR2YWx1ZSA9IF9zdHIodmFsdWUpO1xyXG5cdGlmICghY2hhcnMubGVuZ3RoKSByZXR1cm4gdmFsdWU7XHJcblx0Y2hhcnMgPSBjaGFycy5yZXBsYWNlKC9cXHtkZWZhdWx0XFx9LywgJyBcXHJcXG5cXHRcXGZcXHZcXHgwMCcpO1xyXG5cdGxldCBkMSA9IDAsIGQyID0gMDtcclxuXHRsZXQgX2NoYXJzOiBzdHJpbmdbXSA9IFsuLi5uZXcgU2V0KFsuLi5jaGFyc10pXS5maWx0ZXIodiA9PiB7XHJcblx0XHRpZiAodiA9PT0gJy0nKXtcclxuXHRcdFx0ZDEgPSAxO1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRpZiAodiA9PT0gJ18nKXtcclxuXHRcdFx0ZDIgPSAxO1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9KTtcclxuXHRpZiAoZDIpIF9jaGFycy51bnNoaWZ0KCdfJyk7XHJcblx0aWYgKGQxKSBfY2hhcnMudW5zaGlmdCgnLScpO1xyXG5cdGxldCBwID0gYFske19yZWdFc2NhcGUoX2NoYXJzLmpvaW4oJycpKX1dKmAsIHBhdHRlcm4gPSBgXiR7cH18JHtwfSRgO1xyXG5cdGlmIChbJ2wnLCAnbGVmdCddLmluY2x1ZGVzKHJsKSkgcGF0dGVybiA9IGBeJHtwfWA7XHJcblx0ZWxzZSBpZiAoWydyJywgJ3JpZ2h0J10uaW5jbHVkZXMocmwpKSBwYXR0ZXJuID0gYCR7cH0kYDtcclxuXHRyZXR1cm4gdmFsdWUucmVwbGFjZShuZXcgUmVnRXhwKHBhdHRlcm4sICdncycpLCAnJyk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVnZXggc3RyaW5nIHRyaW0gbGVhZGluZyBjaGFyYWN0ZXJzIChsZWZ0KVxyXG4gKiBcclxuICogQHBhcmFtIHZhbHVlIFRyaW0gdmFsdWVcclxuICogQHBhcmFtIGNoYXJzIFN0cmlwIGNoYXJhY3RlcnMgW2RlZmF1bHQ6IGAnIFxcblxcclxcdFxcZlxcdlxceDAwJ2BdIC0gdXNlIGAne2RlZmF1bHR9J2AgdG8gaW5jbHVkZSBkZWZhdWx0cyAoaS5lIGAnLXtkZWZhdWx0c30nYCA9PSBgJy0gXFxuXFxyXFx0XFxmXFx2XFx4MDAnYClcclxuICovXHJcbmV4cG9ydCBjb25zdCBfbHRyaW0gPSAodmFsdWU6IGFueSwgY2hhcnM6IHN0cmluZyA9ICcgXFxyXFxuXFx0XFxmXFx2XFx4MDAnKTogc3RyaW5nID0+IF90cmltKHZhbHVlLCBjaGFycywgJ2xlZnQnKTtcclxuXHJcbi8qKlxyXG4gKiBSZWdleCBzdHJpbmcgdHJpbSB0cmFpbGluZyBjaGFyYWN0ZXJzIChyaWdodClcclxuICogXHJcbiAqIEBwYXJhbSB2YWx1ZSBUcmltIHZhbHVlXHJcbiAqIEBwYXJhbSBjaGFycyBTdHJpcCBjaGFyYWN0ZXJzIFtkZWZhdWx0OiBgJyBcXG5cXHJcXHRcXGZcXHZcXHgwMCdgXSAtIHVzZSBgJ3tkZWZhdWx0fSdgIHRvIGluY2x1ZGUgZGVmYXVsdHMgKGkuZSBgJy17ZGVmYXVsdHN9J2AgPT0gYCctIFxcblxcclxcdFxcZlxcdlxceDAwJ2ApXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgX3J0cmltID0gKHZhbHVlOiBhbnksIGNoYXJzOiBzdHJpbmcgPSAnIFxcclxcblxcdFxcZlxcdlxceDAwJyk6IHN0cmluZyA9PiBfdHJpbSh2YWx1ZSwgY2hhcnMsICdyaWdodCcpO1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgc3RyaW5nIHRvIHRpdGxlIGNhc2UgKGkuZS4gXCJoZUxMbyB3b1JsZFwiID0+IFwiSGVsbG8gV29ybGRcIilcclxuICogXHJcbiAqIEBwYXJhbSB2YWx1ZSAgUGFyc2Ugc3RyaW5nXHJcbiAqIEBwYXJhbSBrZWVwQ2FzZSAgRGlzYWJsZSBsb3dlcmNhc2luZyB1bmNhcGl0YWxpemVkIGNoYXJhY3RlcnNcclxuICovXHJcbmV4cG9ydCBjb25zdCBfdGl0bGVDYXNlID0gKHZhbHVlOiBhbnksIGtlZXBDYXNlOiBib29sID0gZmFsc2UpOiBzdHJpbmcgPT4gX3N0cih2YWx1ZSlcclxuLnJlcGxhY2UoL1xcd1xcUyovZywgbWF0Y2ggPT4gbWF0Y2hbMF0udG9VcHBlckNhc2UoKVxyXG4rIChrZWVwQ2FzZSA/IG1hdGNoLnN1YnN0cmluZygxKSA6IG1hdGNoLnN1YnN0cmluZygxKS50b0xvd2VyQ2FzZSgpKSk7XHJcblxyXG4vKipcclxuICogQ29udmVydCBzdHJpbmcgdG8gc2VudGVuY2UgY2FzZVxyXG4gKiBcclxuICogQHBhcmFtIHZhbHVlICBQYXJzZSBzdHJpbmdcclxuICogQHBhcmFtIGtlZXBDYXNlICBEaXNhYmxlIGxvd2VyY2FzaW5nIHVuY2FwaXRhbGl6ZWQgY2hhcmFjdGVyc1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IF9zZW50ZW5jZUNhc2UgPSAodmFsdWU6IGFueSwga2VlcENhc2U6IGJvb2wgPSBmYWxzZSk6IHN0cmluZyA9PiBfc3RyKHZhbHVlKVxyXG4uc3BsaXQoLygoPzw9XFwufFxcP3whKVxccyopLylcclxuLm1hcCh2YWwgPT4ge1xyXG4gIGlmICh2YWwubGVuZ3RoKXtcclxuICAgIGNvbnN0IGZpcnN0ID0gdmFsLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgY29uc3QgcmVzdCA9IHZhbC5sZW5ndGggPiAxID8gdmFsLnNsaWNlKDEpIDogJyc7XHJcbiAgICB2YWwgPSBmaXJzdCArIChrZWVwQ2FzZSA/IHJlc3QgOiByZXN0LnRvTG93ZXJDYXNlKCkpO1xyXG4gIH1cclxuICByZXR1cm4gdmFsO1xyXG59KVxyXG4uam9pbignJyk7XHJcblxyXG4vKipcclxuICogQ29udmVydCB2YWx1ZSB0byBzbmFrZSBjYXNlIChpLmUuICdIZWxsb1dvcmxkJyA9PiAnaGVsbG9fd29ybGQnKVxyXG4gKiAtIGFjY2VudHMgYXJlIG5vcm1hbGl6ZWQgKGkuZS4gXCJUZXN0IEFtw6lsaWVcIiA9PiBcInRlc3RfYW1lbGllXCIpXHJcbiAqIFxyXG4gKiBAcGFyYW0gdmFsdWUgIFBhcnNlIHN0cmluZ1xyXG4gKiBAcGFyYW0gdHJpbVRyYWlsaW5nICBUcmltIHRyYWlsaW5nIFwiX1wiIChgZmFsc2VgID0gKGRlZmF1bHQpIGRpc2FibGVkLCBgdHJ1ZWAgPT4gdHJpbSByaWdodCAmIGxlZnQsIGAncid8J3JpZ2h0J2AgPT4gdHJpbSByaWdodCwgYCdsJ3wnbGVmdCdgID0+IHRyaW0gbGVmdClcclxuICovXHJcbmV4cG9ydCBjb25zdCBfc25ha2VDYXNlID0gKHZhbHVlOiBhbnksIHRyaW1UcmFpbGluZzogYm9vbGVhbnwnbCd8J2xlZnQnfCdyJ3wncmlnaHQnID0gZmFsc2UpOiBzdHJpbmcgPT4ge1xyXG5cdGxldCByZXMgPSBfc3RyTm9ybShfdHJpbSh2YWx1ZSkpXHJcblx0LnJlcGxhY2UoL1tBLVpdKy9nLCBtID0+IG1bMF0udG9VcHBlckNhc2UoKSArIG0uc3Vic3RyaW5nKDEpLnRvTG93ZXJDYXNlKCkpXHJcblx0LnJlcGxhY2UoL1xcVysvZywgJyAnKVxyXG5cdC5zcGxpdCgvIHwoPz1bQS1aXSkvKS5qb2luKCdfJykucmVwbGFjZSgvXysvZywgJ18nKS50b0xvd2VyQ2FzZSgpO1xyXG5cdGlmIChyZXMgPT09ICdfJykgcmV0dXJuICcnO1xyXG5cdGlmICgvXl98XyQvLnRlc3QocmVzKSAmJiB0cmltVHJhaWxpbmcpIHJlcyA9IF90cmltKHJlcywgJ18nLCAoWydsJywnbGVmdCcsJ3InLCdyaWdodCddLmluY2x1ZGVzKHRyaW1UcmFpbGluZyBhcyBhbnkpID8gdHJpbVRyYWlsaW5nIDogJycpIGFzIGFueSk7XHJcblx0cmV0dXJuIHJlcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0IHZhbHVlIHRvIHNsdWcgY2FzZSAoaS5lLiAnSGVsbG9Xb3JsZCcgPT4gJ2hlbGxvLXdvcmxkJylcclxuICogXHJcbiAqIEBwYXJhbSB2YWx1ZSAgUGFyc2Ugc3RyaW5nXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgX3NsdWdDYXNlID0gKHZhbHVlOiBhbnksIHRyaW1UcmFpbGluZzogYm9vbGVhbnwnbCd8J2xlZnQnfCdyJ3wncmlnaHQnID0gZmFsc2UpOiBzdHJpbmcgPT4gX3NuYWtlQ2FzZSh2YWx1ZSwgdHJpbVRyYWlsaW5nKS5yZXBsYWNlKC9fL2csICctJyk7XHJcblxyXG4vKipcclxuICogQ29udmVydCB2YWx1ZSB0byBzdHVkbHkgY2FzZSAoaS5lLiAnaGVsbG8td29ybGQnID0+ICdIZWxsb1dvcmxkJylcclxuICogXHJcbiAqIEBwYXJhbSB2YWx1ZSAgUGFyc2Ugc3RyaW5nXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgX3N0dWRseUNhc2UgPSAodmFsdWU6IGFueSk6IHN0cmluZyA9PiBfc25ha2VDYXNlKHZhbHVlKVxyXG4uc3BsaXQoJ18nKVxyXG4uZmlsdGVyKHYgPT4gdi5sZW5ndGgpXHJcbi5tYXAod29yZCA9PiB3b3JkWzBdLnRvVXBwZXJDYXNlKCkgKyB3b3JkLnN1YnN0cmluZygxKS50b0xvd2VyQ2FzZSgpKVxyXG4uam9pbignJyk7XHJcblxyXG4vKipcclxuICogQ29udmVydCB2YWx1ZSB0byBjYW1lbCBjYXNlIChpLmUuICdoZWxsby13b3JsZCcgPT4gJ2hlbGxvV29ybGQnKVxyXG4gKiBcclxuICogQHBhcmFtIHZhbHVlICBQYXJzZSBzdHJpbmdcclxuICovXHJcbmV4cG9ydCBjb25zdCBfY2FtZWxDYXNlID0gKHZhbHVlOiBhbnkpOiBzdHJpbmcgPT4ge1xyXG5cdGxldCByZXMgPSBfc3R1ZGx5Q2FzZSh2YWx1ZSk7XHJcblx0aWYgKHJlcy5sZW5ndGgpIHJlcyA9IHJlc1swXS50b0xvd2VyQ2FzZSgpICsgcmVzLnN1YnN0cmluZygxKTtcclxuXHRyZXR1cm4gcmVzO1xyXG59OyIsImltcG9ydCB7IF9pc0RhdGUsIF90aW1lc3RhbXAgfSBmcm9tICcuL19kYXRldGltZSc7XHJcbmltcG9ydCB7IF9zdHIsIF9zdHJpbmcsIF9zdHJpbmdhYmxlIH0gZnJvbSAnLi9fc3RyaW5nJztcclxuaW1wb3J0IHsgX2pzb25TdHJpbmdpZnksIF9qc29uQ2xvbmUgfSBmcm9tICcuL19qc29uJztcclxuXHJcbi8qKlxyXG4gKiBUZXJtIGZvcm1hdCByZXN1bHQgaW50ZXJmYWNlXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElUZXJtRm9ybWF0IHtcclxuXHRmb3JtYXQ6IChmb3JtYXRzOiBzdHJpbmd8c3RyaW5nW10sIC4uLmFyZ3M6IGFueVtdKSA9PiBJVGVybUZvcm1hdDtcclxuXHR2YWx1ZXM6ICguLi5hcmdzOiBhbnlbXSkgPT4gYW55W107XHJcblx0Y2xlYXI6ICguLi5hcmdzOiBhbnlbXSkgPT4gYW55W107XHJcblx0bG9nOiAobWVzc2FnZT86IGFueSwgLi4ub3B0aW9uYWxQYXJhbXM6IGFueVtdKSA9PiB2b2lkO1xyXG5cdGRlYnVnOiAobWVzc2FnZT86IGFueSwgLi4ub3B0aW9uYWxQYXJhbXM6IGFueVtdKSA9PiB2b2lkO1xyXG5cdHdhcm46IChtZXNzYWdlPzogYW55LCAuLi5vcHRpb25hbFBhcmFtczogYW55W10pID0+IHZvaWQ7XHJcblx0ZXJyb3I6IChtZXNzYWdlPzogYW55LCAuLi5vcHRpb25hbFBhcmFtczogYW55W10pID0+IHZvaWQ7XHJcblx0aW5mbzogKG1lc3NhZ2U/OiBhbnksIC4uLm9wdGlvbmFsUGFyYW1zOiBhbnlbXSkgPT4gdm9pZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRlcm0gYGNvbnNvbGUuKmAgbG9nZ2VyXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgVGVybVxyXG57XHJcblx0LyoqXHJcblx0ICogRGlzYWJsZSBmb3JtYXRzXHJcblx0ICovXHJcblx0c3RhdGljIERJU0FCTEVEOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRleHQgZm9ybWF0c1xyXG5cdCAqL1xyXG5cdHN0YXRpYyBGT1JNQVRTOiB7W2tleTogc3RyaW5nXTogc3RyaW5nfSA9IHtcclxuXHRcdHJlc2V0OiAnXFx4MWJbMG0nLFxyXG5cdFx0YnJpZ2h0OiAnXFx4MWJbMW0nLFxyXG5cdFx0ZGltOiAnXFx4MWJbMm0nLFxyXG5cdFx0dW5kZXJzY29yZTogJ1xceDFiWzRtJyxcclxuXHRcdGJsaW5rOiAnXFx4MWJbNW0nLFxyXG5cdFx0cmV2ZXJzZTogJ1xceDFiWzdtJyxcclxuXHRcdGhpZGRlbjogJ1xceDFiWzhtJyxcclxuXHRcdGZnX2JsYWNrOiAnXFx4MWJbMzBtJyxcclxuXHRcdGZnX3JlZDogJ1xceDFiWzMxbScsXHJcblx0XHRmZ19ncmVlbjogJ1xceDFiWzMybScsXHJcblx0XHRmZ195ZWxsb3c6ICdcXHgxYlszM20nLFxyXG5cdFx0ZmdfYmx1ZTogJ1xceDFiWzM0bScsXHJcblx0XHRmZ19tYWdlbnRhOiAnXFx4MWJbMzVtJyxcclxuXHRcdGZnX2N5YW46ICdcXHgxYlszNm0nLFxyXG5cdFx0Zmdfd2hpdGU6ICdcXHgxYlszN20nLFxyXG5cdFx0ZmdfZ3JheTogJ1xceDFiWzkwbScsXHJcblx0XHRiZ19ibGFjazogJ1xceDFiWzQwbScsXHJcblx0XHRiZ19yZWQ6ICdcXHgxYls0MW0nLFxyXG5cdFx0YmdfZ3JlZW46ICdcXHgxYls0Mm0nLFxyXG5cdFx0YmdfeWVsbG93OiAnXFx4MWJbNDNtJyxcclxuXHRcdGJnX2JsdWU6ICdcXHgxYls0NG0nLFxyXG5cdFx0YmdfbWFnZW50YTogJ1xceDFiWzQ1bScsXHJcblx0XHRiZ19jeWFuOiAnXFx4MWJbNDZtJyxcclxuXHRcdGJnX3doaXRlOiAnXFx4MWJbNDdtJyxcclxuXHRcdGJnX2dyYXk6ICdcXHgxYlsxMDBtJyxcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBQcmVkZWZpbmVkIHRleHQgZm9ybWF0c1xyXG5cdCAqL1xyXG5cdHN0YXRpYyBQUkVERUZJTkVEX0ZPUk1BVFM6IHtba2V5OiBzdHJpbmddOiBzdHJpbmd8c3RyaW5nW119ID0ge1xyXG5cdFx0bG9nOiAnZmdfd2hpdGUnLFxyXG5cdFx0ZGVidWc6ICdmZ19ncmF5JyxcclxuXHRcdGVycm9yOiAnZmdfcmVkJyxcclxuXHRcdHdhcm46ICdmZ195ZWxsb3cnLFxyXG5cdFx0aW5mbzogJ2ZnX2N5YW4nLFxyXG5cdFx0c3VjY2VzczogJ2ZnX2dyZWVuJyxcclxuXHRcdGJnX2xvZzogWydiZ19ibHVlJywgJ2ZnX3doaXRlJ10sXHJcblx0XHRiZ19kZWJ1ZzogWydiZ19ncmF5JywgJ2ZnX2JsYWNrJ10sXHJcblx0XHRiZ19lcnJvcjogWydiZ19yZWQnLCAnZmdfd2hpdGUnXSxcclxuXHRcdGJnX3dhcm46IFsnYmdfeWVsbG93JywgJ2ZnX2JsYWNrJ10sXHJcblx0XHRiZ19pbmZvOiBbJ2JnX2N5YW4nLCAnZmdfYmxhY2snXSxcclxuXHRcdGJnX3N1Y2Nlc3M6IFsnYmdfZ3JlZW4nLCAnZmdfd2hpdGUnXSxcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgc3RhbmRhcmRpemVkIHRleHQgZm9ybWF0c1xyXG5cdCAqIFxyXG5cdCAqIEBwYXJhbSBmb3JtYXRzIFRleHQgZm9ybWF0KHMpXHJcblx0ICogQHJldHVybnMgYHN0cmluZ1tdYFxyXG5cdCAqL1xyXG5cdHN0YXRpYyBnZXRGb3JtYXRzKGZvcm1hdHM6IHN0cmluZ3xzdHJpbmdbXSk6IHN0cmluZ1tdIHtcclxuXHRcdGNvbnN0IEZNID0gdGhpcy5GT1JNQVRTO1xyXG5cdFx0Y29uc3QgUEYgPSB0aGlzLlBSRURFRklORURfRk9STUFUUztcclxuXHRcdGNvbnN0IF9mb3JtYXRzOiBzdHJpbmdbXSA9IEFycmF5LmlzQXJyYXkoZm9ybWF0cykgPyBmb3JtYXRzIDogJ3N0cmluZycgPT09IHR5cGVvZiBmb3JtYXRzID8gW2Zvcm1hdHNdIDogW107XHJcblx0XHRyZXR1cm4gX2Zvcm1hdHMucmVkdWNlPHN0cmluZ1tdPigocHJldiwgdmFsKSA9PiB7XHJcblx0XHRcdGlmICgodmFsID0gdmFsLnRyaW0oKS50b0xvd2VyQ2FzZSgpKSAmJiB2YWwgIT09ICdyZXNldCcpe1xyXG5cdFx0XHRcdGxldCB0bXAgPSB2YWwgPSB2YWwucmVwbGFjZSgvW15hLXowLTldL2lnLCAnXycpLnJlcGxhY2UoJ2dyZXknLCAnZ3JheScpO1xyXG5cdFx0XHRcdGNvbnN0IF9hZGRQRiA9IChrOiBzdHJpbmcpOiB2b2lkID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IHYgPSBQRltrXTtcclxuXHRcdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KHYpKSBwcmV2LnB1c2goLi4udik7XHJcblx0XHRcdFx0XHRlbHNlIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHYpIHByZXYucHVzaCh2KTtcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHRcdGlmIChGTS5oYXNPd25Qcm9wZXJ0eSh2YWwpKSBwcmV2LnB1c2godmFsKTtcclxuXHRcdFx0XHRlbHNlIGlmIChGTS5oYXNPd25Qcm9wZXJ0eSh0bXAgPSBgZmdfJHt2YWx9YCkpIHByZXYucHVzaCh0bXApO1xyXG5cdFx0XHRcdGVsc2UgaWYgKFBGLmhhc093blByb3BlcnR5KHZhbCkpIF9hZGRQRih2YWwpO1xyXG5cdFx0XHRcdGVsc2UgaWYgKFBGLmhhc093blByb3BlcnR5KHRtcCA9IGBiZ18ke3ZhbH1gKSkgX2FkZFBGKHRtcCk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHByZXY7XHJcblx0XHR9LCBbXSk7XHJcblx0fVxyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIFRleHQgZm9ybWF0IGxvZyBhcmd1bWVudHNcclxuXHQgKiBcclxuXHQgKiBAcGFyYW0gZm9ybWF0cyAgVGV4dCBmb3JtYXQocylcclxuXHQgKiBAcGFyYW0gYXJncyAgRm9ybWF0IHZhbHVlc1xyXG5cdCAqIEByZXR1cm5zIGBJVGVybUZvcm1hdGBcclxuXHQgKi9cclxuXHRzdGF0aWMgZm9ybWF0KGZvcm1hdHM6IHN0cmluZ3xzdHJpbmdbXSwgLi4uYXJnczogYW55KTogSVRlcm1Gb3JtYXQge1xyXG5cdFx0bGV0IHRtcDogc3RyaW5nO1xyXG5cdFx0Y29uc3QgX2Zvcm1hdHM6IHN0cmluZ1tdID0gdGhpcy5nZXRGb3JtYXRzKGZvcm1hdHMpO1xyXG5cdFx0Y29uc3QgX2Zvcm1hdCA9ICh2YWw6IGFueSk6IGFueSA9PiB7XHJcblx0XHRcdGlmICh0aGlzLkRJU0FCTEVEIHx8ICFmb3JtYXRzLmxlbmd0aCkgcmV0dXJuIHZhbDtcclxuXHRcdFx0aWYgKCdvYmplY3QnID09PSB0eXBlb2YgdmFsICYmIHZhbCl7XHJcblx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsKSkgcmV0dXJuIHZhbDtcclxuXHRcdFx0XHRpZiAobmV3IFJlZ0V4cCgnXFxcXFtvYmplY3QgXFxcXHcrXFxcXFxcXScpLnRlc3QodG1wID0gX3N0cmluZyh2YWwpKSkgcmV0dXJuIHZhbDtcclxuXHRcdFx0XHRlbHNlIHZhbCA9IHRtcDtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoISgnc3RyaW5nJyA9PT0gdHlwZW9mIHZhbCAmJiB2YWwubGVuZ3RoKSkgcmV0dXJuIHZhbDtcclxuXHRcdFx0cmV0dXJuIF9mb3JtYXRzLnJlZHVjZTxzdHJpbmc+KCh2LCBmKSA9PiB0aGlzLkZPUk1BVFNbZl0gKyB2ICsgdGhpcy5GT1JNQVRTLnJlc2V0LCB2YWwpO1xyXG5cdFx0fTtcclxuXHRcdGNvbnN0IHRoYXQgPSB0aGlzLCBfYXJnczogYW55W10gPSBhcmdzO1xyXG5cdFx0cmV0dXJuIHtcclxuXHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiBBZGQgZm9ybWF0dGVkIHZhbHVlc1xyXG5cdFx0XHQgKiBcclxuXHRcdFx0ICogQHBhcmFtIGZvcm1hdHNcclxuXHRcdFx0ICogQHBhcmFtIGFyZ3NcclxuXHRcdFx0ICovXHJcblx0XHRcdGZvcm1hdChmb3JtYXRzOiBzdHJpbmd8c3RyaW5nW10sIC4uLmFyZ3M6IGFueVtdKTogSVRlcm1Gb3JtYXQge1xyXG5cdFx0XHRcdF9hcmdzLnB1c2godGhhdC5mb3JtYXQoZm9ybWF0cywgLi4uYXJncykudmFsdWVzKCkpO1xyXG5cdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIEdldCBmb3JtYXR0ZWQgdmFsdWVzXHJcblx0XHRcdCAqIFxyXG5cdFx0XHQgKiBAcGFyYW0gYXJnc1xyXG5cdFx0XHQgKi9cclxuXHRcdFx0dmFsdWVzKC4uLmFyZ3M6IGFueVtdKTogYW55W10ge1xyXG5cdFx0XHRcdHJldHVybiBfYXJncy5jb25jYXQoYXJncykubWFwKHZhbCA9PiBfZm9ybWF0KHZhbCkpO1xyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIEdldCB2YWx1ZXMgd2l0aG91dCBmb3JtYXR0aW5nXHJcblx0XHRcdCAqIFxyXG5cdFx0XHQgKiBAcGFyYW0gYXJnc1xyXG5cdFx0XHQgKi9cclxuXHRcdFx0Y2xlYXIoLi4uYXJnczogYW55W10pOiBhbnlbXSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoYXQuY2xlYXIoLi4udGhpcy52YWx1ZXMoLi4uYXJncykpO1xyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIGBjb25zb2xlLmxvZ2AgZm9ybWF0dGVkIHZhbHVlc1xyXG5cdFx0XHQgKiBcclxuXHRcdFx0ICogQHBhcmFtIGFyZ3MgXHJcblx0XHRcdCAqL1xyXG5cdFx0XHRsb2coLi4uYXJnczogYW55W10pOiB2b2lkIHtcclxuXHRcdFx0XHRjb25zb2xlLmxvZyguLi50aGlzLnZhbHVlcyguLi5hcmdzKSk7XHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogYGNvbnNvbGUuZGVidWdgIGZvcm1hdHRlZCB2YWx1ZXNcclxuXHRcdFx0ICogXHJcblx0XHRcdCAqIEBwYXJhbSBhcmdzIFxyXG5cdFx0XHQgKi9cclxuXHRcdFx0ZGVidWcoLi4uYXJnczogYW55W10pOiB2b2lkIHtcclxuXHRcdFx0XHRjb25zb2xlLmRlYnVnKC4uLnRoaXMudmFsdWVzKC4uLmFyZ3MpKTtcclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiBgY29uc29sZS53YXJuYCBmb3JtYXR0ZWQgdmFsdWVzXHJcblx0XHRcdCAqIFxyXG5cdFx0XHQgKiBAcGFyYW0gYXJncyBcclxuXHRcdFx0ICovXHJcblx0XHRcdHdhcm4oLi4uYXJnczogYW55W10pOiB2b2lkIHtcclxuXHRcdFx0XHRjb25zb2xlLndhcm4oLi4udGhpcy52YWx1ZXMoLi4uYXJncykpO1xyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIGBjb25zb2xlLmVycm9yYCBmb3JtYXR0ZWQgdmFsdWVzXHJcblx0XHRcdCAqIFxyXG5cdFx0XHQgKiBAcGFyYW0gYXJncyBcclxuXHRcdFx0ICovXHJcblx0XHRcdGVycm9yKC4uLmFyZ3M6IGFueVtdKTogdm9pZCB7XHJcblx0XHRcdFx0Y29uc29sZS5lcnJvciguLi50aGlzLnZhbHVlcyguLi5hcmdzKSk7XHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogYGNvbnNvbGUuaW5mb2AgZm9ybWF0dGVkIHZhbHVlc1xyXG5cdFx0XHQgKiBcclxuXHRcdFx0ICogQHBhcmFtIGFyZ3MgXHJcblx0XHRcdCAqL1xyXG5cdFx0XHRpbmZvKC4uLmFyZ3M6IGFueVtdKTogdm9pZCB7XHJcblx0XHRcdFx0Y29uc29sZS5pbmZvKC4uLnRoaXMudmFsdWVzKC4uLmFyZ3MpKTtcclxuXHRcdFx0fSxcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDbGVhciB0ZXh0IHZhbHVlIGZvcm1hdHRpbmdcclxuXHQgKiBcclxuXHQgKiBAcGFyYW0gYXJncyAgRm9ybWF0dGVkIHZhbHVlc1xyXG5cdCAqIEByZXR1cm5zIGBhbnlbXWAgQ2xlYXIgdmFsdWVzXHJcblx0ICovXHJcblx0c3RhdGljIGNsZWFyKC4uLmFyZ3M6IGFueVtdKTogYW55W10ge1xyXG5cdFx0Y29uc3QgX2NsZWFyID0gKHZhbDogc3RyaW5nKTogc3RyaW5nID0+IE9iamVjdC52YWx1ZXModGhpcy5GT1JNQVRTKS5yZWR1Y2U8c3RyaW5nPigocCwgdik9PiBwLnJlcGxhY2UobmV3IFJlZ0V4cChTdHJpbmcodikucmVwbGFjZSgvXFx4MUIvLCAnXFxcXHgxQicpLnJlcGxhY2UoL1xcWy8sICdcXFxcWycpLCAnZycpLCAnJyksIHZhbCk7XHJcblx0XHRyZXR1cm4gYXJncy5tYXAoKHZhbDogYW55KSA9PiAnc3RyaW5nJyA9PT0gdHlwZW9mIHZhbCAmJiB2YWwudHJpbSgpLmxlbmd0aCA/IF9jbGVhcih2YWwpIDogdmFsKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBmb3JtYXR0ZWQgdGV4dFxyXG5cdCAqIFxyXG5cdCAqIEBwYXJhbSB2YWx1ZSAgVGV4dCB2YWx1ZVxyXG5cdCAqIEBwYXJhbSBmb3JtYXRzICBUZXh0IGZvcm1hdChzKVxyXG5cdCAqIEByZXR1cm5zIGBzdHJpbmdgIEZvcm1hdHRlZFxyXG5cdCAqL1xyXG5cdHN0YXRpYyB0ZXh0KHZhbHVlOiBzdHJpbmcsIGZvcm1hdHM/OiBzdHJpbmd8c3RyaW5nW10pOiBzdHJpbmcge1xyXG5cdFx0Y29uc3QgX3ZhbDogc3RyaW5nID0gX3N0cmluZyh2YWx1ZSksIF9mb3JtYXRzOiBzdHJpbmdbXSA9IChBcnJheS5pc0FycmF5KGZvcm1hdHMpID8gZm9ybWF0cyA6ICdzdHJpbmcnID09PSB0eXBlb2YgZm9ybWF0cyA/IFtmb3JtYXRzXSA6IFtdKS5maWx0ZXIodiA9PiAnc3RyaW5nJyA9PT0gdHlwZW9mIHYgJiYgISF2LnRyaW0oKSk7XHJcblx0XHRpZiAoIShfZm9ybWF0cy5sZW5ndGggJiYgX3ZhbC50cmltKCkubGVuZ3RoKSkgcmV0dXJuIF92YWw7XHJcblx0XHRyZXR1cm4gdGhpcy5mb3JtYXQoX2Zvcm1hdHMsIF92YWwpLnZhbHVlcygpWzBdO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogTG9nIGBjb25zb2xlLmxvZ2AgZm9ybWF0XHJcblx0ICogXHJcblx0ICogQHBhcmFtIGFyZ3NcclxuXHQgKi9cclxuXHRzdGF0aWMgbG9nKC4uLmFyZ3M6IGFueVtdKTogdm9pZCB7XHJcblx0XHR0aGlzLmZvcm1hdCgnbG9nJywgLi4uYXJncykubG9nKCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBEZWJ1ZyBgY29uc29sZS5kZWJ1Z2AgZm9ybWF0XHJcblx0ICogXHJcblx0ICogQHBhcmFtIGFyZ3NcclxuXHQgKi9cclxuXHRzdGF0aWMgZGVidWcoLi4uYXJnczogYW55W10pOiB2b2lkIHtcclxuXHRcdHRoaXMuZm9ybWF0KCdkZWJ1ZycsIC4uLmFyZ3MpLmRlYnVnKCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBFcnJvciBgY29uc29sZS5lcnJvcmAgZm9ybWF0XHJcblx0ICogXHJcblx0ICogQHBhcmFtIGFyZ3NcclxuXHQgKi9cclxuXHRzdGF0aWMgZXJyb3IoLi4uYXJnczogYW55W10pOiB2b2lkIHtcclxuXHRcdHRoaXMuZm9ybWF0KCdlcnJvcicsIC4uLmFyZ3MpLmVycm9yKCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBXYXJuIGBjb25zb2xlLndhcm5gIGZvcm1hdFxyXG5cdCAqIFxyXG5cdCAqIEBwYXJhbSBhcmdzXHJcblx0ICovXHJcblx0c3RhdGljIHdhcm4oLi4uYXJnczogYW55KTogdm9pZCB7XHJcblx0XHR0aGlzLmZvcm1hdCgnd2FybicsIC4uLmFyZ3MpLndhcm4oKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEluZm8gYGNvbnNvbGUuaW5mb2AgZm9ybWF0XHJcblx0ICogXHJcblx0ICogQHBhcmFtIGFyZ3NcclxuXHQgKi9cclxuXHRzdGF0aWMgaW5mbyguLi5hcmdzOiBhbnkpOiB2b2lkIHtcclxuXHRcdHRoaXMuZm9ybWF0KCdpbmZvJywgLi4uYXJncykuaW5mbygpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU3VjY2VzcyBgY29uc29sZS5sb2dgIGZvcm1hdFxyXG5cdCAqIFxyXG5cdCAqIEBwYXJhbSBhcmdzXHJcblx0ICovXHJcblx0c3RhdGljIHN1Y2Nlc3MoLi4uYXJnczogYW55KTogdm9pZCB7XHJcblx0XHR0aGlzLmZvcm1hdCgnc3VjY2VzcycsIC4uLmFyZ3MpLmxvZygpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHZhbHVlIGxpc3RcclxuXHQgKiBcclxuXHQgKiBAcGFyYW0gdmFsdWVcclxuXHQgKiBAcGFyYW0gX2VudHJpZXNcclxuXHQgKi9cclxuXHRzdGF0aWMgbGlzdCh2YWx1ZTogYW55LCBfZW50cmllczogYm9vbGVhbiA9IGZhbHNlKTogW2xpc3Q6IGFueVtdLCB0eXBlOid2YWx1ZXMnfCdlbnRyaWVzJ10ge1xyXG5cdFx0bGV0IGl0ZW1zOiBhbnlbXSA9IFt2YWx1ZV0sIHR5cGU6ICd2YWx1ZXMnfCdlbnRyaWVzJyA9ICd2YWx1ZXMnO1xyXG5cdFx0aWYgKCdvYmplY3QnID09PSB0eXBlb2YgdmFsdWUgJiYgdmFsdWUpe1xyXG5cdFx0XHRpZiAoISh0eXBlID0gdmFsdWVbU3ltYm9sLml0ZXJhdG9yXT8ubmFtZSkpe1xyXG5cdFx0XHRcdHR5cGUgPSAndmFsdWVzJztcclxuXHRcdFx0XHRpdGVtcyA9IFt2YWx1ZV07XHJcblx0XHRcdFx0aWYgKF9lbnRyaWVzICYmIF9zdHJpbmdhYmxlKHZhbHVlKSA9PT0gZmFsc2Upe1xyXG5cdFx0XHRcdFx0bGV0IHRtcDogYW55ID0gX2pzb25DbG9uZTxhbnk+KHZhbHVlKSwgdG1wX2VudHJpZXM6IFtrOiBhbnksIHY6IGFueV1bXSA9IFtdO1xyXG5cdFx0XHRcdFx0aWYgKCEoJ29iamVjdCcgPT09IHR5cGVvZiB0bXAgJiYgdG1wICYmICh0bXBfZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHRtcCkpLmxlbmd0aCkpIHRtcF9lbnRyaWVzID0gT2JqZWN0LmVudHJpZXModmFsdWUpO1xyXG5cdFx0XHRcdFx0aWYgKHRtcF9lbnRyaWVzLmxlbmd0aCl7XHJcblx0XHRcdFx0XHRcdHR5cGUgPSAnZW50cmllcyc7XHJcblx0XHRcdFx0XHRcdGl0ZW1zID0gdG1wX2VudHJpZXM7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYgKHR5cGUgPT09ICdlbnRyaWVzJykgaXRlbXMgPSBfZW50cmllcyA/IFsuLi52YWx1ZV0gOiBbdmFsdWVdO1xyXG5cdFx0XHRlbHNlIGl0ZW1zID0gWy4uLnZhbHVlXTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBbaXRlbXMsIHR5cGVdO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ3VzdG9tIGBjb25zb2xlLnRhYmxlYCBsb2dnZXJcclxuXHQgKiBcclxuXHQgKiBAcGFyYW0gZGF0YVxyXG5cdCAqIEBwYXJhbSBjZWxsTWF4TGVuZ3RoXHJcblx0ICovXHJcblx0c3RhdGljIHRhYmxlKGRhdGE6IGFueSwgY2VsbE1heExlbmd0aDogbnVtYmVyID0gMjQ4LCBkaXZpZGVyOiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcclxuXHRcdFxyXG5cdFx0Ly92YXJzXHJcblx0XHRjb25zdCB0aGF0ID0gdGhpcztcclxuXHRcdGNvbnN0IFtkYXRhX2l0ZW1zLCBkYXRhX3R5cGVdID0gdGhhdC5saXN0KGRhdGEsICdvYmplY3QnID09PSB0eXBlb2YgZGF0YSAmJiBkYXRhICYmICFfc3RyaW5nYWJsZShkYXRhKSk7XHJcblxyXG5cdFx0Ly9mbiA9PiBzdHIgdmFsdWVcclxuXHRcdGNvbnN0IHN0clZhbCA9ICh2YWw6IGFueSk6IFtfdmFsdWU6IHN0cmluZywgX2Zvcm1hdDogc3RyaW5nXSA9PiB7XHJcblx0XHRcdGxldCBjb2xvcjogc3RyaW5nLCB0bXA6IGFueTtcclxuXHRcdFx0aWYgKCFBcnJheS5pc0FycmF5KHZhbCkgJiYgKHRtcCA9IF9zdHJpbmdhYmxlKHZhbCkpICE9PSBmYWxzZSl7XHJcblx0XHRcdFx0Y29sb3IgPSAnZ3JlZW4nO1xyXG5cdFx0XHRcdGlmICgnbnVtYmVyJyA9PT0gdHlwZW9mIHZhbCkgY29sb3IgPSAneWVsbG93JztcclxuXHRcdFx0XHRlbHNlIGlmICh2YWwgPT09IHVuZGVmaW5lZCB8fCB2YWwgPT09IG51bGwpIGNvbG9yID0gJ2dyYXknO1xyXG5cdFx0XHRcdGVsc2UgaWYgKHZhbCA9PT0gdHJ1ZSkgY29sb3IgPSAnY3lhbic7XHJcblx0XHRcdFx0ZWxzZSBpZiAodmFsID09PSBmYWxzZSkgY29sb3IgPSAncmVkJztcclxuXHRcdFx0XHRlbHNlIGlmICgvXlxcZHs0fS0oPzowWzEtOV18MVswLTJdKS0oPzpbMC0yXVsxLTldfFsxLTNdMHwzWzAxXSlUKD86WzAtMV1bMC05XXwyWzAtM10pKD86OlswLTZdXFxkKSg/OjpbMC02XVxcZCk/KD86XFwuXFxkezN9KT8oPzpbKy1dWzAtMl1cXGQ6WzAtNV1cXGR8Wik/JC8udGVzdCh0bXApKSBjb2xvciA9ICdtYWdlbnRhJzsgLy9tYXRjaCBJU08gdGltZXN0YW1wIChpLmUuIDIwMjMtMDYtMDlUMTg6MTg6NTcuMDcwWilcclxuXHRcdFx0XHR2YWwgPSB0bXA7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0aWYgKCdvYmplY3QnID09PSB0eXBlb2YgdmFsICYmIHZhbCl7XHJcblx0XHRcdFx0XHRjb25zdCBfdHlwZSA9IHZhbFtTeW1ib2wuaXRlcmF0b3JdO1xyXG5cdFx0XHRcdFx0aWYgKCEhX3R5cGUpe1xyXG5cdFx0XHRcdFx0XHR2YWwgPSBbLi4udmFsXTtcclxuXHRcdFx0XHRcdFx0aWYgKF90eXBlID09PSAnZW50cmllcycpIHZhbCA9IE9iamVjdC5mcm9tRW50cmllcyh2YWwpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZWxzZSB2YWwgPSBfanNvbkNsb25lPGFueT4odmFsKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dmFsID0gX2pzb25TdHJpbmdpZnkodmFsKTtcclxuXHRcdFx0XHRjb2xvciA9ICdtYWdlbnRhJztcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gW3ZhbCwgY29sb3JdO1xyXG5cdFx0fTtcclxuXHJcblx0XHQvL3ZhbHVlIGxvZyAtIGNhbm5vdCBiZSB0YWJsZWRcclxuXHRcdGlmIChkYXRhX3R5cGUgPT09ICd2YWx1ZXMnICYmIGRhdGFfaXRlbXMubGVuZ3RoIDwgMil7XHJcblx0XHRcdGNvbnN0IFtfdmFsdWUsIF9mb3JtYXRdID0gc3RyVmFsKGRhdGEpO1xyXG5cdFx0XHRjb25zb2xlLmxvZyh0aGF0LnRleHQoX3ZhbHVlLCBfZm9ybWF0KSk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvL3RhYmxlIGl0ZW1zXHJcblx0XHRsZXQgbW9kZTogJ3ZhbHVlcyd8J2VudHJpZXMnO1xyXG5cdFx0Y29uc3QgdGFibGVfaXRlbXM6IGFueVtdW10gPSBbXTtcclxuXHRcdGlmIChkYXRhX3R5cGUgPT09ICdlbnRyaWVzJyl7XHJcblx0XHRcdHRhYmxlX2l0ZW1zLnB1c2goWycoaW5kZXgpJywgJ1ZhbHVlcyddKTtcclxuXHRcdFx0dGFibGVfaXRlbXMucHVzaCguLi5kYXRhX2l0ZW1zKTtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRsZXQgbWFwX2tleXM6IHN0cmluZ1tdID0gW10sIG1hcF9pdGVtczoge1trZXk6IHN0cmluZ106IGFueX1bXSA9IFtdO1xyXG5cdFx0XHRkYXRhX2l0ZW1zLmZvckVhY2goKGRhdGFfaXRlbSwgcikgPT4ge1xyXG5cdFx0XHRcdGxldCBbbGlzdF9pdGVtcywgbGlzdF90eXBlXSA9IHRoYXQubGlzdChkYXRhX2l0ZW0sICFyIHx8IG1vZGUgPT09ICdlbnRyaWVzJyk7XHJcblx0XHRcdFx0aWYgKCFyKSBtb2RlID0gbGlzdF90eXBlO1xyXG5cdFx0XHRcdGNvbnN0IG1hcF9pdGVtOiB7W2tleTogc3RyaW5nXTogYW55fSA9IHt9O1xyXG5cdFx0XHRcdGxpc3RfaXRlbXMuZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xyXG5cdFx0XHRcdFx0bGV0IGs6IHN0cmluZywgdjogYW55O1xyXG5cdFx0XHRcdFx0aWYgKGxpc3RfdHlwZSA9PT0gJ2VudHJpZXMnKXtcclxuXHRcdFx0XHRcdFx0ayA9IF9zdHIoaXRlbVswXSwgdHJ1ZSwgdHJ1ZSk7XHJcblx0XHRcdFx0XHRcdHYgPSBpdGVtWzFdO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRcdGsgPSBgJHtpfWA7XHJcblx0XHRcdFx0XHRcdHYgPSBpdGVtO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKCFtYXBfa2V5cy5pbmNsdWRlcyhrKSkgbWFwX2tleXMucHVzaChrKTtcclxuXHRcdFx0XHRcdG1hcF9pdGVtW2tdID0gdjtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0XHRtYXBfaXRlbXMucHVzaChtYXBfaXRlbSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHR0YWJsZV9pdGVtcy5wdXNoKFsnKGluZGV4KScsIC4uLm1hcF9rZXlzXSk7XHJcblx0XHRcdG1hcF9pdGVtcy5mb3JFYWNoKChtYXBfaXRlbSwgcikgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IHRhYmxlX2l0ZW06IGFueVtdID0gW107XHJcblx0XHRcdFx0Zm9yIChjb25zdCBrZXkgb2YgbWFwX2tleXMpIHRhYmxlX2l0ZW0ucHVzaChtYXBfaXRlbVtrZXldKTtcclxuXHRcdFx0XHR0YWJsZV9pdGVtcy5wdXNoKFtyLCAuLi50YWJsZV9pdGVtXSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vd2lkdGhcclxuXHRcdGNvbnN0IHdpZHRoX21hcDoge1trZXk6IG51bWJlcl06IG51bWJlcn0gPSB7fTtcclxuXHRcdGNvbnN0IHN0cl9pdGVtczogW192YWx1ZTogc3RyaW5nLCBfZm9ybWF0OiBzdHJpbmddW11bXSA9IFtdO1xyXG5cdFx0dGFibGVfaXRlbXMuZm9yRWFjaCh0YWJsZV9pdGVtID0+IHtcclxuXHRcdFx0Y29uc3Qgc3RyX2l0ZW06IFtfdmFsdWU6IHN0cmluZywgX2Zvcm1hdDogc3RyaW5nXVtdID0gW107XHJcblx0XHRcdHRhYmxlX2l0ZW0uZm9yRWFjaCgodmFsLCBpKSA9PiB7XHJcblx0XHRcdFx0Y29uc3QgW192YWx1ZSwgX2Zvcm1hdF0gPSBzdHJWYWwodmFsKTtcclxuXHRcdFx0XHRpZiAoIXdpZHRoX21hcC5oYXNPd25Qcm9wZXJ0eShpKSkgd2lkdGhfbWFwW2ldID0gMDtcclxuXHRcdFx0XHRsZXQgbGVuID0gX3ZhbHVlLmxlbmd0aDtcclxuXHRcdFx0XHRpZiAobGVuID4gY2VsbE1heExlbmd0aCkgbGVuID0gY2VsbE1heExlbmd0aDsgLy9jZWxsTWF4TGVuZ3RoIGxpbWl0XHJcblx0XHRcdFx0aWYgKGxlbiA+IHdpZHRoX21hcFtpXSkgd2lkdGhfbWFwW2ldID0gbGVuO1xyXG5cdFx0XHRcdHN0cl9pdGVtLnB1c2goW192YWx1ZSwgX2Zvcm1hdF0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0c3RyX2l0ZW1zLnB1c2goc3RyX2l0ZW0pO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly9yb3dzXHJcblx0XHRjb25zdCByb3dzX2xlbjogbnVtYmVyID0gc3RyX2l0ZW1zLmxlbmd0aDtcclxuXHRcdHN0cl9pdGVtcy5mb3JFYWNoKChzdHJfaXRlbSwgcikgPT4ge1xyXG5cdFx0XHRsZXQgbWF4X2xpbmVzOiBudW1iZXIgPSAwLCBzdHJfaXRlbV9saW5lczogc3RyaW5nW11bXSA9IFtdO1xyXG5cdFx0XHRzdHJfaXRlbS5mb3JFYWNoKCh2YWwsIGkpID0+IHtcclxuXHRcdFx0XHRsZXQgW192YWx1ZSwgX2Zvcm1hdF0gPSB2YWw7XHJcblx0XHRcdFx0aWYgKCFpIHx8ICFyKSBfZm9ybWF0ID0gKCFpICYmIHIgJiYgbW9kZSA9PT0gJ3ZhbHVlcycpID8gJ2dyYXknIDogJ3doaXRlJztcclxuXHRcdFx0XHRjb25zdCB3aWR0aDogbnVtYmVyID0gd2lkdGhfbWFwW2ldO1xyXG5cdFx0XHRcdGNvbnN0IGxpbmVzOiBzdHJpbmdbXSA9IFtdO1xyXG5cdFx0XHRcdGlmIChfdmFsdWUubGVuZ3RoID4gd2lkdGgpe1xyXG5cdFx0XHRcdFx0d2hpbGUgKF92YWx1ZS5sZW5ndGggPiB3aWR0aCkge1xyXG5cdFx0XHRcdFx0XHRjb25zdCBsaW5lID0gX3ZhbHVlLnN1YnN0cmluZygwLCB3aWR0aCkucGFkRW5kKHdpZHRoKTtcclxuXHRcdFx0XHRcdFx0X3ZhbHVlID0gX3ZhbHVlLnNsaWNlKHdpZHRoKTtcclxuXHRcdFx0XHRcdFx0bGluZXMucHVzaCh0aGF0LnRleHQobGluZSwgX2Zvcm1hdCkpOyAvL2Zvcm1hdFxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKF92YWx1ZS5sZW5ndGgpIGxpbmVzLnB1c2godGhhdC50ZXh0KF92YWx1ZS5wYWRFbmQod2lkdGgpLCBfZm9ybWF0KSk7IC8vZm9ybWF0XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2UgbGluZXMucHVzaCh0aGF0LnRleHQoX3ZhbHVlLnBhZEVuZCh3aWR0aCksIF9mb3JtYXQpKTsgLy9mb3JtYXRcclxuXHRcdFx0XHRzdHJfaXRlbV9saW5lcy5wdXNoKGxpbmVzKTtcclxuXHRcdFx0XHRpZiAobWF4X2xpbmVzIDwgbGluZXMubGVuZ3RoKSBtYXhfbGluZXMgPSBsaW5lcy5sZW5ndGg7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRzdHJfaXRlbV9saW5lcyA9IHN0cl9pdGVtX2xpbmVzLm1hcCgobGluZXMsIGMpID0+IHtcclxuXHRcdFx0XHRjb25zdCB3aWR0aDogbnVtYmVyID0gd2lkdGhfbWFwW2NdO1xyXG5cdFx0XHRcdHJldHVybiBbLi4uQXJyYXkobWF4X2xpbmVzKV0ubWFwKChfLCBpKSA9PiB7XHJcblx0XHRcdFx0XHRjb25zdCBsaW5lID0gaSA8IGxpbmVzLmxlbmd0aCA/IGxpbmVzW2ldIDogJycucGFkRW5kKHdpZHRoKTtcclxuXHRcdFx0XHRcdHJldHVybiBsaW5lO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0Y29uc3QgbGluZV9yb3dzOnN0cmluZ1tdW10gPSBbLi4uQXJyYXkobWF4X2xpbmVzKV0ubWFwKCgpID0+IFtdKTtcclxuXHRcdFx0c3RyX2l0ZW1fbGluZXMuZm9yRWFjaCgobGluZXMsIGMpID0+IHtcclxuXHRcdFx0XHRsaW5lcy5mb3JFYWNoKChsaW5lLCBpKSA9PiBsaW5lX3Jvd3NbaV1bY10gPSBsaW5lKTtcclxuXHRcdFx0fSk7XHJcblx0XHRcdGNvbnN0IHJvd3M6IHN0cmluZ1tdID0gW107XHJcblx0XHRcdGNvbnN0IGxlbiA9IGxpbmVfcm93cy5sZW5ndGg7XHJcblx0XHRcdGxpbmVfcm93cy5mb3JFYWNoKChsaW5lX3JvdywgbikgPT4ge1xyXG5cdFx0XHRcdGlmICghbiAmJiAhcikgcm93cy5wdXNoKCfilIzilIAnICsgbGluZV9yb3cubWFwKChfLCBpKSA9PiAnJy5wYWRFbmQod2lkdGhfbWFwW2ldLCAn4pSAJykpLmpvaW4oJ+KUgOKUrOKUgCcpICsgJ+KUgOKUkCcpOyAvL2JvcmRlciB0b3BcclxuXHRcdFx0XHRyb3dzLnB1c2goJ+KUgiAnICsgbGluZV9yb3cuam9pbignIOKUgiAnKSArICcg4pSCJyk7XHJcblx0XHRcdFx0aWYgKCghciB8fCBkaXZpZGVyKSAmJiBuICsgMSA9PT0gbGVuICYmIHIgKyAxIDwgcm93c19sZW4pIHJvd3MucHVzaCgn4pSc4pSAJyArIGxpbmVfcm93Lm1hcCgoXywgaSkgPT4gJycucGFkRW5kKHdpZHRoX21hcFtpXSwgJ+KUgCcpKS5qb2luKCfilIDilLzilIAnKSArICfilIDilKQnKTsgLy9ib3JkZXIgbWlkXHJcblx0XHRcdFx0aWYgKG4gKyAxID09PSBsZW4gJiYgciArIDEgPT09IHJvd3NfbGVuKSByb3dzLnB1c2goJ+KUlOKUgCcgKyBsaW5lX3Jvdy5tYXAoKF8sIGkpID0+ICcnLnBhZEVuZCh3aWR0aF9tYXBbaV0sICfilIAnKSkuam9pbign4pSA4pS04pSAJykgKyAn4pSA4pSYJyk7IC8vYm9yZGVyIGJvdHRvbVxyXG5cdFx0XHR9KTtcclxuXHRcdFx0cm93cy5mb3JFYWNoKHJvdyA9PiBjb25zb2xlLmxvZyhyb3cpKTtcclxuXHRcdH0pO1xyXG5cdH1cclxufVxyXG5cclxuXHJcbi8vVEVTVCBUQUJMRVxyXG4vLyBjb25zdCBfdmFsdWVzOiBhbnlbXSA9IGBcclxuLy8gSW4gZXUgZmV1Z2lhdCBpcHN1bSwgaWQgZXVpc21vZCBuaXNpLlxyXG4vLyBTZWQgc2VtIHZlbGl0LCBmYWNpbGlzaXMgdml0YWUgdHVycGlzIHV0LCBvcm5hcmUgZmluaWJ1cyBsYWN1cy5cclxuLy8gUHJvaW4gc29kYWxlcyB2ZXN0aWJ1bHVtIG1hdXJpcyBldSB0ZW1wb3IuIENyYXMgc2l0IGFtZXQgdmVoaWN1bGEgdXJuYS5cclxuLy8gTWFlY2VuYXMgZmV1Z2lhdCB2YXJpdXMgdmVsaXQgZXUgZWdlc3Rhcy4gRG9uZWMgZmluaWJ1cyBsb3JlbSBldCB0ZW1wb3IgbG9ib3J0aXMuXHJcbi8vIE51bGxhbSB0aW5jaWR1bnQgcG9zdWVyZSBuaWJoLCB2b2x1dHBhdCBpbXBlcmRpZXQgb3JjaSByaG9uY3VzIGV1LiBWZXN0aWJ1bHVtIG1heGltdXMgcnV0cnVtIGVyYXQgYWMgZmF1Y2lidXMuXHJcbi8vIE1hdXJpcyB2aXRhZSB0ZW1wb3IgdmVsaXQuXHJcbi8vIEN1cmFiaXR1ciB1bHRyaWNpZXMgbnVuYyBub24gbWFzc2EgYXVjdG9yLCB2ZWwgdGluY2lkdW50IHR1cnBpcyBlbGVtZW50dW0uXHJcbi8vIGAudHJpbSgpLnNwbGl0KCdcXG4nKS5tYXAodiA9PiB2LnRyaW0oKSk7XHJcbi8vIGNvbnN0IF9zZXQgPSBuZXcgU2V0PG51bWJlcj4oWzEsIDIsIDIsIDQsIDVdKTtcclxuLy8gY29uc3QgX21hcCA9IG5ldyBNYXA8c3RyaW5nLCBhbnk+KFtbJ25hbWUnLCAnTWFydGluJ10sIFsnYWdlJywgMzBdLCBbJ3Bob25lJywgNDQ0NTU1XV0pO1xyXG4vLyBjb25zdCBfY2lyYyA9ICgoKT0+eyBjb25zdCB4diA9IHtuYW1lOid0ZXN0WFYnLF9nZXQ6ZnVuY3Rpb24odGhpczogYW55KXtjb25zdCBzZWxmID0gdGhpczsgc2VsZi5feHYgPSBzZWxmOyByZXR1cm4gc2VsZjt9fTsgcmV0dXJuIHh2Ll9nZXQoKTsgfSkoKTtcclxuLy8gX3ZhbHVlcy5wdXNoKC4uLltuZXcgRGF0ZSgpLCBuZXcgVHlwZUVycm9yKCdIZWxsbyBlcnJvci4nKSwgX3NldCwgX21hcCwgX2NpcmNdKTtcclxuLy8gY29uc3QgX2JhdGNoID0gX2JhdGNoVmFsdWVzKF92YWx1ZXMsIDMpLm1hcChhcnIgPT4gIShfcmFuZCgwLCAxMCklMikgPyBhcnIuc2xpY2UoMCkgOiBhcnIuc2xpY2UoMCkucmV2ZXJzZSgpKTtcclxuLy8gY29uc3QgX29iamVjdHM6IGFueVtdID0gX2pzb25DbG9uZTxhbnlbXVtdPihfYmF0Y2gpLm1hcChhcnIgPT4gT2JqZWN0LmZyb21FbnRyaWVzKGFyci5tYXAoKHYsIGkpID0+IFtgY29sICR7aX1gLCB2XSkpKTtcclxuLy8gY29uc3QgX29iamVjdDogYW55ID0gX29iamVjdHNbX3JhbmQoMCwgX29iamVjdHMubGVuZ3RoIC0gMSldO1xyXG4vLyBjb25zdCBfYXJyOiBhbnlbXSA9IFsuLi5BcnJheSg1KV0ubWFwKChfLCByKSA9PiBbLi4uQXJyYXkoNCldLm1hcCgoXywgYykgPT4gYCR7W3IsIGNdfWApKTtcclxuLy8gLy90ZXN0c1xyXG4vLyBjb25zdCBfdGVzdHM6IHtba2V5OiBzdHJpbmddOiBhbnl9ID0ge1xyXG4vLyBcdF9zZXQsXHJcbi8vIFx0X21hcCxcclxuLy8gXHRfYmF0Y2gsXHJcbi8vIFx0X29iamVjdCxcclxuLy8gXHRfYXJyLFxyXG4vLyBcdF9zdHI6ICdDdXJhYml0dXIgdWx0cmljaWVzIG51bmMgbm9uIG1hc3NhIGF1Y3RvciwgdmVsIHRpbmNpZHVudCB0dXJwaXMgZWxlbWVudHVtLicsXHJcbi8vIFx0X251bTogX3JhbmQoMTAwMCwgMTAwMDAwKSxcclxuLy8gXHRfZGF0ZTogbmV3IERhdGUoKSxcclxuLy8gXHRfZXJyOiBuZXcgRXJyb3IoJ0hlbGxvIGVycm9yIScpLFxyXG4vLyBcdF9ib29sOiBbdHJ1ZSwgZmFsc2VdLFxyXG4vLyB9O1xyXG4vLyBPYmplY3QuZW50cmllcyhfdGVzdHMpLmZvckVhY2goKGVudHJ5LCBpKSA9PiB7XHJcbi8vIFx0Y29uc3QgW2tleSwgdmFsdWVdID0gZW50cnk7XHJcbi8vIFx0Y29uc29sZS5sb2coJycpO1xyXG4vLyBcdFRlcm0ud2FybihgLS0tIFske2l9XSB0ZXN0IC0gJHtrZXl9YCwgdmFsdWU/Lmxlbmd0aCA/PyAnJyk7XHJcbi8vIFx0VGVybS50YWJsZSh2YWx1ZSwgMzIpO1xyXG4vLyB9KTtcclxuLy8gLy90YWJsZVxyXG4vLyBjb25zb2xlLmxvZygnJyk7XHJcbi8vIFRlcm0uZGVidWcoJz09PSB0YWJsZScpO1xyXG4vLyBjb25zb2xlLnRhYmxlKF9hcnIpO1xyXG4vLyBjb25zb2xlLnRhYmxlKF9vYmplY3QpO1xyXG4vLyByZXR1cm47IiwiLy9fY29tbW9uXHJcbmV4cG9ydCB0eXBlIHtcclxuXHRib29sLFxyXG59IGZyb20gJy4vX2NvbW1vbic7XHJcblxyXG4vL19oZWxsb1xyXG5leHBvcnQge1xyXG5cdF9zYXlIZWxsbyxcclxufSBmcm9tICcuL19oZWxsbyc7XHJcblxyXG4vL19qc29uXHJcbmV4cG9ydCB7XHJcblx0X2pzb25TdHJpbmdpZnksXHJcblx0X2pzb25QYXJzZSxcclxuXHRfanNvbkNsb25lLFxyXG59IGZyb20gJy4vX2pzb24nO1xyXG5cclxuLy9fc3RyaW5nXHJcbmV4cG9ydCB7XHJcblx0X3V1aWQsXHJcblx0X3N0cmluZyxcclxuXHRfc3RyaW5nYWJsZSxcclxuXHRfc3RyLFxyXG5cdF9zdHJOb3JtLFxyXG5cdF9yZWdFc2NhcGUsXHJcblx0X3N0ckVzY2FwZSxcclxuXHRfdHJpbSxcclxuXHRfbHRyaW0sXHJcblx0X3J0cmltLFxyXG5cdF90aXRsZUNhc2UsXHJcblx0X3NlbnRlbmNlQ2FzZSxcclxuXHRfc25ha2VDYXNlLFxyXG5cdF9zbHVnQ2FzZSxcclxuXHRfc3R1ZGx5Q2FzZSxcclxuXHRfY2FtZWxDYXNlLFxyXG59IGZyb20gJy4vX3N0cmluZyc7XHJcblxyXG4vL19iYXRjaFxyXG5leHBvcnQge1xyXG5cdF9iYXRjaFZhbHVlcyxcclxufSBmcm9tICcuL19iYXRjaCc7XHJcblxyXG4vL19kYXRldGltZVxyXG5leHBvcnQge1xyXG5cdF9pc0RhdGUsXHJcblx0X2dldERhdGUsXHJcblx0X2RhdGV0aW1lLFxyXG5cdF90aW1lc3RhbXAsXHJcbn0gZnJvbSAnLi9fZGF0ZXRpbWUnO1xyXG5cclxuZXhwb3J0IHtcclxuXHRfaXNOdW1lcmljLFxyXG5cdF90b051bSxcclxuXHRfbnVtLFxyXG5cdF9pbnQsXHJcblx0X3JvdW5kLFxyXG5cdF9jb21tYXMsXHJcblx0X3JhbmQsXHJcbn0gZnJvbSAnLi9fbnVtYmVyJztcclxuXHJcbi8vX3Byb21pc2VcclxuZXhwb3J0IHR5cGUge1xyXG5cdElQcm9taXNlUmVzdWx0LFxyXG59IGZyb20gJy4vX3Byb21pc2UnO1xyXG5cclxuZXhwb3J0IHtcclxuXHRfYXN5bmNBbGwsXHJcblx0X2FzeW5jVmFsdWVzLFxyXG5cdF9zbGVlcCxcclxufSBmcm9tICcuL19wcm9taXNlJztcclxuXHJcbi8vX3F1ZXVlXHJcbmV4cG9ydCB0eXBlIHtcclxuXHRJUXVldWUsXHJcbn0gZnJvbSAnLi9fcXVldWUnO1xyXG5cclxuZXhwb3J0IHtcclxuXHRfcXVldWUsXHJcbn0gZnJvbSAnLi9fcXVldWUnO1xyXG5cclxuLy9fc29ydFxyXG5leHBvcnQgdHlwZSB7XHJcblx0U29ydERpcmVjdGlvbixcclxuXHRTb3J0T3JkZXIsXHJcbn0gZnJvbSAnLi9fc29ydCc7XHJcblxyXG5leHBvcnQge1xyXG5cdF9zb3J0VmFsdWVzLFxyXG59IGZyb20gJy4vX3NvcnQnO1xyXG5cclxuLy9fdGVybVxyXG5leHBvcnQgdHlwZSB7XHJcblx0SVRlcm1Gb3JtYXQsXHJcbn0gZnJvbSAnLi9fdGVybSc7XHJcblxyXG5leHBvcnQge1xyXG5cdFRlcm0sXHJcbn0gZnJvbSAnLi9fdGVybSc7XHJcblxyXG4vL19FbGFwc2VkVGltZVxyXG5leHBvcnQge1xyXG5cdEVsYXBzZWRUaW1lLFxyXG59IGZyb20gJy4vX0VsYXBzZWRUaW1lJztcclxuXHJcbi8vX29iamVjdHNcclxuZXhwb3J0IHtcclxuXHRfZmxhdHRlbixcclxuXHRfaGFzUHJvcCxcclxuXHRfaGFzUHJvcHMsXHJcblx0X2hhc0FueVByb3BzLFxyXG59IGZyb20gJy4vX29iamVjdHMnO1xyXG5cclxuLy9fZGVib3VuY2VkXHJcbmV4cG9ydCB7XHJcblx0X2RlYm91Y2VkLFxyXG59IGZyb20gJy4vX2RlYm91Y2VkJztcclxuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIiIsIi8vIHN0YXJ0dXBcbi8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLy8gVGhpcyBlbnRyeSBtb2R1bGUgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBtb2R1bGVzIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbGliL2luZGV4LnRzXCIpO1xuIiwiIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9